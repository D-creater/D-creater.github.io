<!DOCTYPE html>
<html lang=en>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>Hexo</title>
  <meta name="description" content="title:JUC• 课程内容概览 1 、什么是JUC 2 、Lock接口 3 、线程间通信 4 、集合的线程安全 5 、多线程锁 6 、Callable接口 7 、JUC三大辅助类: CountDownLatch CyclicBarrier Semaphore 8 、读写锁: ReentrantReadWriteLock 9 、阻塞队列 10 、ThreadPool线程池 11 、Fork&amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2022/06/27/JUC/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="title:JUC• 课程内容概览 1 、什么是JUC 2 、Lock接口 3 、线程间通信 4 、集合的线程安全 5 、多线程锁 6 、Callable接口 7 、JUC三大辅助类: CountDownLatch CyclicBarrier Semaphore 8 、读写锁: ReentrantReadWriteLock 9 、阻塞队列 10 、ThreadPool线程池 11 、Fork&amp;#">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-06-27T03:19:52.767Z">
<meta property="article:modified_time" content="2022-06-27T09:55:08.799Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="http://example.com/2022/06/27/JUC/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.2.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/cofess" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">D-creater</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Web Developer &amp; Designer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> Shenzhen, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">Repository</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-books">
          <a href="/books">
            
            <i class="icon icon-book-fill"></i>
            
            <span class="menu-title">Books</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-links">
          <a href="/links">
            
            <i class="icon icon-friendship"></i>
            
            <span class="menu-title">Links</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">About</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      

    
      

    
      
    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">June 2022</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/06/27/JUC/" class="title">(no title)</a>
              </p>
              <p class="item-date">
                <time datetime="2022-06-27T03:19:52.767Z" itemprop="datePublished">2022-06-27</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                
              </p>
              <p class="item-title">
                <a href="/2022/06/22/docker/" class="title">(no title)</a>
              </p>
              <p class="item-date">
                <time datetime="2022-06-22T03:17:53.435Z" itemprop="datePublished">2022-06-22</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-JUC" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/06/27/JUC/" class="article-date">
	  <time datetime="2022-06-27T03:19:52.767Z" itemprop="datePublished">2022-06-27</time>
	</a>
</span>
        
        

        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/06/27/JUC/#comments" class="article-comment-link">Comments</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <hr>
<h2 id="title-JUC"><a href="#title-JUC" class="headerlink" title="title:JUC"></a>title:JUC</h2><h2 id="•-课程内容概览"><a href="#•-课程内容概览" class="headerlink" title="• 课程内容概览"></a>• 课程内容概览</h2><ul>
<li>1 、什么是JUC</li>
<li>2 、Lock接口</li>
<li>3 、线程间通信</li>
<li>4 、集合的线程安全</li>
<li>5 、多线程锁</li>
<li>6 、Callable接口</li>
<li>7 、JUC三大辅助类: CountDownLatch CyclicBarrier Semaphore</li>
<li>8 、读写锁: ReentrantReadWriteLock</li>
<li>9 、阻塞队列</li>
<li>10 、ThreadPool线程池</li>
<li>11 、Fork&#x2F;Join框架</li>
<li>12 、CompletableFuture</li>
</ul>
<h1 id="1-什么是-JUC"><a href="#1-什么是-JUC" class="headerlink" title="1 什么是 JUC"></a>1 什么是 JUC</h1><h2 id="1-1-JUC简介"><a href="#1-1-JUC简介" class="headerlink" title="1.1 JUC简介"></a>1.1 JUC简介</h2><h4 id="在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC"><a href="#在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC" class="headerlink" title="在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC"></a>在Java中，线程部分是一个重点，本篇文章说的JUC也是关于线程的。JUC</h4><h4 id="就是java-util-concurrent工具包的简称。这是一个处理线程的工具包，JDK"><a href="#就是java-util-concurrent工具包的简称。这是一个处理线程的工具包，JDK" class="headerlink" title="就是java.util .concurrent工具包的简称。这是一个处理线程的工具包，JDK"></a>就是java.util .concurrent工具包的简称。这是一个处理线程的工具包，JDK</h4><h4 id="1-5开始出现的。"><a href="#1-5开始出现的。" class="headerlink" title="1.5开始出现的。"></a>1.5开始出现的。</h4><h2 id="1-2-进程与线程"><a href="#1-2-进程与线程" class="headerlink" title="1.2 进程与线程"></a>1.2 进程与线程</h2><h4 id="进程（Process）-是计算机中的程序关于某数据集合上的一次运行活动，是系"><a href="#进程（Process）-是计算机中的程序关于某数据集合上的一次运行活动，是系" class="headerlink" title="进程（Process） 是计算机中的程序关于某数据集合上的一次运行活动，是系"></a>进程（Process） 是计算机中的程序关于某数据集合上的一次运行活动，是系</h4><h4 id="统进行资源分配和调度的基本单位，是操作系统结构的基础。-在当代面向线程"><a href="#统进行资源分配和调度的基本单位，是操作系统结构的基础。-在当代面向线程" class="headerlink" title="统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程"></a>统进行资源分配和调度的基本单位，是操作系统结构的基础。 在当代面向线程</h4><h4 id="设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的"><a href="#设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的" class="headerlink" title="设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的"></a>设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的</h4><h4 id="描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活"><a href="#描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活" class="headerlink" title="描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活"></a>描述，进程是程序的实体。是计算机中的程序关于某数据集合上的一次运行活</h4><h4 id="动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是"><a href="#动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是" class="headerlink" title="动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是"></a>动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。程序是</h4><h4 id="指令、数据及其组织形式的描述，进程是程序的实体。"><a href="#指令、数据及其组织形式的描述，进程是程序的实体。" class="headerlink" title="指令、数据及其组织形式的描述，进程是程序的实体。"></a>指令、数据及其组织形式的描述，进程是程序的实体。</h4><h4 id="线程（thread）-是操作系统能够进行运算调度的最小单位。它被包含在进程之"><a href="#线程（thread）-是操作系统能够进行运算调度的最小单位。它被包含在进程之" class="headerlink" title="线程（thread） 是操作系统能够进行运算调度的最小单位。它被包含在进程之"></a>线程（thread） 是操作系统能够进行运算调度的最小单位。它被包含在进程之</h4><h4 id="中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，"><a href="#中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，" class="headerlink" title="中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，"></a>中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，</h4><h4 id="一个进程中可以并发多个线程，每条线程并行执行不同的任务。"><a href="#一个进程中可以并发多个线程，每条线程并行执行不同的任务。" class="headerlink" title="一个进程中可以并发多个线程，每条线程并行执行不同的任务。"></a>一个进程中可以并发多个线程，每条线程并行执行不同的任务。</h4><h4 id="总结来说"><a href="#总结来说" class="headerlink" title="总结来说:"></a>总结来说:</h4><h4 id="进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程—"><a href="#进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程—" class="headerlink" title="进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程—"></a>进程：指在系统中正在运行的一个应用程序；程序一旦运行就是进程；进程—</h4><h4 id="—资源分配的最小单位。"><a href="#—资源分配的最小单位。" class="headerlink" title="—资源分配的最小单位。"></a>—资源分配的最小单位。</h4><h4 id="线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个"><a href="#线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个" class="headerlink" title="线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个"></a>线程：系统分配处理器时间资源的基本单元，或者说进程之内独立执行的一个</h4><h4 id="单元执行流。线程——程序执行的最小单位。"><a href="#单元执行流。线程——程序执行的最小单位。" class="headerlink" title="单元执行流。线程——程序执行的最小单位。"></a>单元执行流。线程——程序执行的最小单位。</h4><h2 id="1-3-线程的状态"><a href="#1-3-线程的状态" class="headerlink" title="1.3 线程的状态"></a>1.3 线程的状态</h2><h3 id="1-3-1-线程状态枚举类"><a href="#1-3-1-线程状态枚举类" class="headerlink" title="1.3.1 线程状态枚举类"></a>1.3.1 线程状态枚举类</h3><h4 id="Thread-State"><a href="#Thread-State" class="headerlink" title="Thread.State"></a>Thread.State</h4><p>public enum State {<br>&#x2F;**</p>
<ul>
<li>Thread state for a thread which has not yet started.<br>*&#x2F;<br>NEW,(新建)</li>
</ul>
<p>&#x2F;**</p>
<ul>
<li>Thread state for a runnable thread. A thread in the runnable</li>
<li>state is executing in the Java virtual machine but it may</li>
<li>be waiting for other resources from the operating system</li>
<li>such as processor.<br>*&#x2F;<br>RUNNABLE,（准备就绪）</li>
</ul>
<p>&#x2F;**</p>
<ul>
<li>Thread state for a thread blocked waiting for a monitor lock.</li>
<li>A thread in the blocked state is waiting for a monitor lock</li>
<li>to enter a synchronized block&#x2F;method or</li>
<li>reenter a synchronized block&#x2F;method after calling</li>
<li>{@link Object#wait() Object.wait}.<br>*&#x2F;<br>BLOCKED,（阻塞）</li>
</ul>
<p>&#x2F;**</p>
<ul>
<li>Thread state for a waiting thread.</li>
<li>A thread is in the waiting state due to calling one of the</li>
<li>following methods:</li>
<li><ul></li>
<li><li>{@link Object#wait() Object.wait} with no timeout</li></li>
<li><li>{@link #join() Thread.join} with no timeout</li></li>
<li><li>{@link LockSupport#park() LockSupport.park}</li></li>
<li></ul></li>
<li></li>
<li><p>A thread in the waiting state is waiting for another thread to</li>
<li>perform a particular action.</li>
<li></li>
<li>For example, a thread that has called <tt>Object.wait()</tt></li>
<li>on an object is waiting for another thread to call</li>
<li><tt>Object.notify()</tt> or <tt>Object.notifyAll()</tt> on</li>
<li>that object. A thread that has called <tt>Thread.join()</tt></li>
<li>is waiting for a specified thread to terminate.<br>*&#x2F;<br>WAITING,（不见不散）</li>
</ul>
<p>&#x2F;**</p>
<ul>
<li><p>Thread state for a waiting thread with a specified waiting time.</p>
</li>
<li><p>A thread is in the timed waiting state due to calling one of</p>
</li>
<li><p>the following methods with a specified positive waiting time:</p>
</li>
<li><ul></li>
<li><li>{@link #sleep Thread.sleep}</li>

</li>
<li><li>{@link Object#wait(long) Object.wait} with timeout</li></li>
<li><li>{@link #join(long) Thread.join} with timeout</li></li>
<li><li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li></li>
<li><li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li></li>
<li></ul>
*/
TIMED_WAITING,（过时不候）</li>
</ul>
<p>&#x2F;**</p>
<ul>
<li>Thread state for a terminated thread.</li>
<li>The thread has completed execution.<br>*&#x2F;<br>TERMINATED;(终结)<br>}</li>
</ul>
<h3 id="1-3-2-wait-x2F-sleep的区别"><a href="#1-3-2-wait-x2F-sleep的区别" class="headerlink" title="1.3.2 wait&#x2F;sleep的区别"></a>1.3.2 wait&#x2F;sleep的区别</h3><h4 id="（-1-）sleep是Thread的静态方法，wait是Object的方法，任何对象实例都"><a href="#（-1-）sleep是Thread的静态方法，wait是Object的方法，任何对象实例都" class="headerlink" title="（ 1 ）sleep是Thread的静态方法，wait是Object的方法，任何对象实例都"></a>（ 1 ）sleep是Thread的静态方法，wait是Object的方法，任何对象实例都</h4><h4 id="能调用。"><a href="#能调用。" class="headerlink" title="能调用。"></a>能调用。</h4><h4 id="（-2-）sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提"><a href="#（-2-）sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提" class="headerlink" title="（ 2 ）sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提"></a>（ 2 ）sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提</h4><h4 id="是当前线程占有锁-即代码要在synchronized中-。"><a href="#是当前线程占有锁-即代码要在synchronized中-。" class="headerlink" title="是当前线程占有锁(即代码要在synchronized中)。"></a>是当前线程占有锁(即代码要在synchronized中)。</h4><h4 id="（-3-）它们都可以被interrupted方法中断。"><a href="#（-3-）它们都可以被interrupted方法中断。" class="headerlink" title="（ 3 ）它们都可以被interrupted方法中断。"></a>（ 3 ）它们都可以被interrupted方法中断。</h4><h2 id="1-4-并发与并行"><a href="#1-4-并发与并行" class="headerlink" title="1.4 并发与并行"></a>1.4 并发与并行</h2><h3 id="1-4-1-串行模式"><a href="#1-4-1-串行模式" class="headerlink" title="1.4.1 串行模式"></a>1.4.1 串行模式</h3><h4 id="串行表示所有任务都一一按先后顺序进行。串行意味着必须先装完一车柴才能"><a href="#串行表示所有任务都一一按先后顺序进行。串行意味着必须先装完一车柴才能" class="headerlink" title="串行表示所有任务都一一按先后顺序进行。串行意味着必须先装完一车柴才能"></a>串行表示所有任务都一一按先后顺序进行。串行意味着必须先装完一车柴才能</h4><h4 id="运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步"><a href="#运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步" class="headerlink" title="运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步"></a>运送这车柴，只有运送到了，才能卸下这车柴，并且只有完成了这整个三个步</h4><h4 id="骤，才能进行下一个步骤。"><a href="#骤，才能进行下一个步骤。" class="headerlink" title="骤，才能进行下一个步骤。"></a>骤，才能进行下一个步骤。</h4><h4 id="串行是一次只能取得一个任务，并执行这个任务-。"><a href="#串行是一次只能取得一个任务，并执行这个任务-。" class="headerlink" title="串行是一次只能取得一个任务，并执行这个任务 。"></a>串行是一次只能取得一个任务，并执行这个任务 。</h4><h3 id="1-4-2-并行模式"><a href="#1-4-2-并行模式" class="headerlink" title="1.4.2 并行模式"></a>1.4.2 并行模式</h3><h4 id="并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模"><a href="#并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模" class="headerlink" title="并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模"></a>并行意味着可以同时取得多个任务，并同时去执行所取得的这些任务。并行模</h4><h4 id="式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列"><a href="#式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列" class="headerlink" title="式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列"></a>式相当于将长长的一条队列，划分成了多条短队列，所以并行缩短了任务队列</h4><h4 id="的长度。并行的效率从代码层次上强依赖于多进程-x2F-多线程代码，从硬件角度上"><a href="#的长度。并行的效率从代码层次上强依赖于多进程-x2F-多线程代码，从硬件角度上" class="headerlink" title="的长度。并行的效率从代码层次上强依赖于多进程&#x2F;多线程代码，从硬件角度上"></a>的长度。并行的效率从代码层次上强依赖于多进程&#x2F;多线程代码，从硬件角度上</h4><h4 id="则依赖于多核CPU。"><a href="#则依赖于多核CPU。" class="headerlink" title="则依赖于多核CPU。"></a>则依赖于多核CPU。</h4><h3 id="1-4-3-并发"><a href="#1-4-3-并发" class="headerlink" title="1.4.3 并发"></a>1.4.3 并发</h3><h4 id="并发-concurrent-指的是多个程序可以同时运行的现象，更细化的是多进程可"><a href="#并发-concurrent-指的是多个程序可以同时运行的现象，更细化的是多进程可" class="headerlink" title="并发(concurrent)指的是多个程序可以同时运行的现象，更细化的是多进程可"></a>并发(concurrent)指的是多个程序可以同时运行的现象，更细化的是多进程可</h4><h4 id="以同时运行或者多指令可以同时运行-。但这不是重点，在描述并发的时候也不"><a href="#以同时运行或者多指令可以同时运行-。但这不是重点，在描述并发的时候也不" class="headerlink" title="以同时运行或者多指令可以同时运行 。但这不是重点，在描述并发的时候也不"></a>以同时运行或者多指令可以同时运行 。但这不是重点，在描述并发的时候也不</h4><h4 id="会去扣这种字眼是否精确，-x3D-x3D-并发的重点在于它是一种现象-x3D-x3D-x3D-x3D-并发描述"><a href="#会去扣这种字眼是否精确，-x3D-x3D-并发的重点在于它是一种现象-x3D-x3D-x3D-x3D-并发描述" class="headerlink" title="会去扣这种字眼是否精确，&#x3D;&#x3D;并发的重点在于它是一种现象&#x3D;&#x3D;, &#x3D;&#x3D;并发描述"></a>会去扣这种字眼是否精确，&#x3D;&#x3D;并发的重点在于它是一种现象&#x3D;&#x3D;, &#x3D;&#x3D;并发描述</h4><h4 id="的是多进程同时运行的现象-x3D-x3D-。但实际上，对于单核心CPU来说，同一时刻"><a href="#的是多进程同时运行的现象-x3D-x3D-。但实际上，对于单核心CPU来说，同一时刻" class="headerlink" title="的是多进程同时运行的现象&#x3D;&#x3D;。但实际上，对于单核心CPU来说，同一时刻"></a>的是多进程同时运行的现象&#x3D;&#x3D;。但实际上，对于单核心CPU来说，同一时刻</h4><h4 id="只能运行一个线程。所以，这里的”同时运行”表示的不是真的同一时刻有多个"><a href="#只能运行一个线程。所以，这里的”同时运行”表示的不是真的同一时刻有多个" class="headerlink" title="只能运行一个线程。所以，这里的”同时运行”表示的不是真的同一时刻有多个"></a>只能运行一个线程。所以，这里的”同时运行”表示的不是真的同一时刻有多个</h4><h4 id="线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同"><a href="#线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同" class="headerlink" title="线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同"></a>线程运行的现象，这是并行的概念，而是提供一种功能让用户看来多个程序同</h4><h4 id="时运行起来了，但实际上这些程序中的进程不是一直霸占CPU的，而是执行一"><a href="#时运行起来了，但实际上这些程序中的进程不是一直霸占CPU的，而是执行一" class="headerlink" title="时运行起来了，但实际上这些程序中的进程不是一直霸占CPU的，而是执行一"></a>时运行起来了，但实际上这些程序中的进程不是一直霸占CPU的，而是执行一</h4><h4 id="会停一会。"><a href="#会停一会。" class="headerlink" title="会停一会。"></a>会停一会。</h4><h4 id="要解决大并发问题，通常是将大任务分解成多个小任务-由于操作系统对进程的"><a href="#要解决大并发问题，通常是将大任务分解成多个小任务-由于操作系统对进程的" class="headerlink" title="要解决大并发问题，通常是将大任务分解成多个小任务 , 由于操作系统对进程的"></a>要解决大并发问题，通常是将大任务分解成多个小任务 , 由于操作系统对进程的</h4><h4 id="调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可"><a href="#调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可" class="headerlink" title="调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可"></a>调度是随机的，所以切分成多个小任务后，可能会从任一小任务处执行。这可</h4><h4 id="能会出现一些现象："><a href="#能会出现一些现象：" class="headerlink" title="能会出现一些现象："></a>能会出现一些现象：</h4><ul>
<li>可能出现一个小任务执行了多次，还没开始下个任务的情况。这时一般会采用</li>
</ul>
<h4 id="队列或类似的数据结构来存放各个小任务的成果"><a href="#队列或类似的数据结构来存放各个小任务的成果" class="headerlink" title="队列或类似的数据结构来存放各个小任务的成果"></a>队列或类似的数据结构来存放各个小任务的成果</h4><ul>
<li>可能出现还没准备好第一步就执行第二步的可能。这时，一般采用多路复用或</li>
</ul>
<h4 id="异步的方式，比如只有准备好产生了事件通知才执行某个任务。"><a href="#异步的方式，比如只有准备好产生了事件通知才执行某个任务。" class="headerlink" title="异步的方式，比如只有准备好产生了事件通知才执行某个任务。"></a>异步的方式，比如只有准备好产生了事件通知才执行某个任务。</h4><ul>
<li>可以多进程&#x2F;多线程的方式并行执行这些小任务。也可以单进程&#x2F;单线程执行这</li>
</ul>
<h4 id="些小任务，这时很可能要配合多路复用才能达到较高的效率"><a href="#些小任务，这时很可能要配合多路复用才能达到较高的效率" class="headerlink" title="些小任务，这时很可能要配合多路复用才能达到较高的效率"></a>些小任务，这时很可能要配合多路复用才能达到较高的效率</h4><h3 id="1-4-4-小结-重点"><a href="#1-4-4-小结-重点" class="headerlink" title="1.4.4 小结(重点)"></a>1.4.4 小结(重点)</h3><h4 id="并发：-同一时刻多个线程在访问同一个资源，多个线程对一个点"><a href="#并发：-同一时刻多个线程在访问同一个资源，多个线程对一个点" class="headerlink" title="并发： 同一时刻多个线程在访问同一个资源，多个线程对一个点"></a>并发： 同一时刻多个线程在访问同一个资源，多个线程对一个点</h4><h4 id="例子：春运抢票-电商秒杀…"><a href="#例子：春运抢票-电商秒杀…" class="headerlink" title="例子：春运抢票 电商秒杀…"></a>例子：春运抢票 电商秒杀…</h4><h4 id="并行：-多项工作一起执行，之后再汇总"><a href="#并行：-多项工作一起执行，之后再汇总" class="headerlink" title="并行： 多项工作一起执行，之后再汇总"></a>并行： 多项工作一起执行，之后再汇总</h4><h4 id="例子：泡方便面，电水壶烧水，一边撕调料倒入桶中"><a href="#例子：泡方便面，电水壶烧水，一边撕调料倒入桶中" class="headerlink" title="例子：泡方便面，电水壶烧水，一边撕调料倒入桶中"></a>例子：泡方便面，电水壶烧水，一边撕调料倒入桶中</h4><h2 id="1-5管程"><a href="#1-5管程" class="headerlink" title="1.5管程"></a>1.5管程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">管程(monitor)是保证了同一时刻只有一个进程在管程内活动,即管程内定义的操作在同</span><br><span class="line">一时刻只被一个进程调用(由编译器实现).但是这样并不能保证进程以设计的顺序执行</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JVM中同步是基于进入和退出管程(monitor)对象实现的，每个对象都会有一个管程</span><br><span class="line">(monitor)对象，管程(monitor)会随着java对象一同创建和销毁</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">执行线程首先要持有管程对象，然后才能执行方法，当方法完成之后会释放管程，方</span><br><span class="line">法在执行时候会持有管程，其他线程无法再获取同一个管程</span><br></pre></td></tr></table></figure>
<h2 id="1-6用户线程和守护线程"><a href="#1-6用户线程和守护线程" class="headerlink" title="1.6用户线程和守护线程"></a>1.6用户线程和守护线程</h2><h5 id="用户线程-平时用到的普通线程-自定义线程"><a href="#用户线程-平时用到的普通线程-自定义线程" class="headerlink" title="用户线程: 平时用到的普通线程,自定义线程"></a>用户线程: 平时用到的普通线程,自定义线程</h5><h5 id="守护线程-运行在后台-是一种特殊的线程-比如垃圾回收"><a href="#守护线程-运行在后台-是一种特殊的线程-比如垃圾回收" class="headerlink" title="守护线程: 运行在后台,是一种特殊的线程,比如垃圾回收"></a>守护线程: 运行在后台,是一种特殊的线程,比如垃圾回收</h5><h5 id="当主线程结束后-用户线程还在运行-JVM存活"><a href="#当主线程结束后-用户线程还在运行-JVM存活" class="headerlink" title="当主线程结束后,用户线程还在运行,JVM存活"></a>当主线程结束后,用户线程还在运行,JVM存活</h5><h5 id="如果没有用户线程-都是守护线程-JVM结束"><a href="#如果没有用户线程-都是守护线程-JVM结束" class="headerlink" title="如果没有用户线程,都是守护线程,JVM结束"></a>如果没有用户线程,都是守护线程,JVM结束</h5><h1 id="2-Lock-接口"><a href="#2-Lock-接口" class="headerlink" title="2 Lock 接口"></a>2 Lock 接口</h1><h2 id="2-1-Synchronized"><a href="#2-1-Synchronized" class="headerlink" title="2.1 Synchronized"></a>2.1 Synchronized</h2><h3 id="2-1-1-Synchronized关键字回顾"><a href="#2-1-1-Synchronized关键字回顾" class="headerlink" title="2.1.1 Synchronized关键字回顾"></a>2.1.1 Synchronized关键字回顾</h3><h4 id="synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种："><a href="#synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：" class="headerlink" title="synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种："></a>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</h4><h4 id="1-修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号"><a href="#1-修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号" class="headerlink" title="1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}"></a>1. 修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}</h4><h4 id="括起来的代码，作用的对象是调用这个代码块的对象；"><a href="#括起来的代码，作用的对象是调用这个代码块的对象；" class="headerlink" title="括起来的代码，作用的对象是调用这个代码块的对象；"></a>括起来的代码，作用的对象是调用这个代码块的对象；</h4><h4 id="2-修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用"><a href="#2-修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用" class="headerlink" title="2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用"></a>2. 修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用</h4><h4 id="的对象是调用这个方法的对象；"><a href="#的对象是调用这个方法的对象；" class="headerlink" title="的对象是调用这个方法的对象；"></a>的对象是调用这个方法的对象；</h4><h4 id="o-虽然可以使用synchronized来定义方法，但synchronized并不属于方法定"><a href="#o-虽然可以使用synchronized来定义方法，但synchronized并不属于方法定" class="headerlink" title="o 虽然可以使用synchronized来定义方法，但synchronized并不属于方法定"></a>o 虽然可以使用synchronized来定义方法，但synchronized并不属于方法定</h4><h4 id="义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方"><a href="#义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方" class="headerlink" title="义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方"></a>义的一部分，因此，synchronized关键字不能被继承。如果在父类中的某个方</h4><h4 id="法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这"><a href="#法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这" class="headerlink" title="法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这"></a>法使用了synchronized关键字，而在子类中覆盖了这个方法，在子类中的这</h4><h4 id="个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上"><a href="#个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上" class="headerlink" title="个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上"></a>个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上</h4><h4 id="synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方"><a href="#synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方" class="headerlink" title="synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方"></a>synchronized关键字才可以。当然，还可以在子类方法中调用父类中相应的方</h4><h4 id="法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，"><a href="#法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，" class="headerlink" title="法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，"></a>法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，</h4><h4 id="子类的方法也就相当于同步了。"><a href="#子类的方法也就相当于同步了。" class="headerlink" title="子类的方法也就相当于同步了。"></a>子类的方法也就相当于同步了。</h4><h4 id="3-修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的"><a href="#3-修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的" class="headerlink" title="3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的"></a>3. 修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的</h4><h4 id="所有对象；"><a href="#所有对象；" class="headerlink" title="所有对象；"></a>所有对象；</h4><h4 id="4-修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主"><a href="#4-修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主" class="headerlink" title="4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主"></a>4. 修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主</h4><h4 id="的对象是这个类的所有对象。"><a href="#的对象是这个类的所有对象。" class="headerlink" title="的对象是这个类的所有对象。"></a>的对象是这个类的所有对象。</h4><h4 id="2-1-2-售票案例"><a href="#2-1-2-售票案例" class="headerlink" title="2.1.2 售票案例"></a>2.1.2 售票案例</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Ticket &#123;</span><br><span class="line">// 票数</span><br><span class="line">private int number = 30 ;</span><br><span class="line">// 操作方法：卖票</span><br><span class="line">public synchronized void sale() &#123;</span><br><span class="line">// 判断：是否有票</span><br><span class="line">if ( number &gt; 0 ) &#123;</span><br><span class="line">System. out .println(Thread. currentThread ().getName()+ &quot; :</span><br><span class="line">&quot; +( number --)+ &quot; &quot; + number );</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执"><a href="#如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执" class="headerlink" title="如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执"></a>如果一个代码块被synchronized修饰了，当一个线程获取了对应的锁，并执</h4><h4 id="行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里"><a href="#行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里" class="headerlink" title="行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里"></a>行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里</h4><h4 id="获取锁的线程释放锁只会有两种情况："><a href="#获取锁的线程释放锁只会有两种情况：" class="headerlink" title="获取锁的线程释放锁只会有两种情况："></a>获取锁的线程释放锁只会有两种情况：</h4><h4 id="1-）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；"><a href="#1-）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；" class="headerlink" title="1 ）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；"></a>1 ）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；</h4><h4 id="2-）线程执行发生异常，此时JVM会让线程自动释放锁。"><a href="#2-）线程执行发生异常，此时JVM会让线程自动释放锁。" class="headerlink" title="2 ）线程执行发生异常，此时JVM会让线程自动释放锁。"></a>2 ）线程执行发生异常，此时JVM会让线程自动释放锁。</h4><h4 id="那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep"><a href="#那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep" class="headerlink" title="那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep"></a>那么如果这个获取锁的线程由于要等待IO或者其他原因（比如调用sleep</h4><h4 id="方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一"><a href="#方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一" class="headerlink" title="方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一"></a>方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一</h4><h4 id="下，这多么影响程序执行效率。"><a href="#下，这多么影响程序执行效率。" class="headerlink" title="下，这多么影响程序执行效率。"></a>下，这多么影响程序执行效率。</h4><h4 id="因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等"><a href="#因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等" class="headerlink" title="因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等"></a>因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等</h4><h4 id="待一定的时间或者能够响应中断），通过Lock就可以办到。"><a href="#待一定的时间或者能够响应中断），通过Lock就可以办到。" class="headerlink" title="待一定的时间或者能够响应中断），通过Lock就可以办到。"></a>待一定的时间或者能够响应中断），通过Lock就可以办到。</h4><h4 id="2-2-什么是Lock"><a href="#2-2-什么是Lock" class="headerlink" title="2.2 什么是Lock"></a>2.2 什么是Lock</h4><h4 id="Lock锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允"><a href="#Lock锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允" class="headerlink" title="Lock锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允"></a>Lock锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允</h4><h4 id="许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对"><a href="#许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对" class="headerlink" title="许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对"></a>许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对</h4><h4 id="象。Lock提供了比synchronized更多的功能。"><a href="#象。Lock提供了比synchronized更多的功能。" class="headerlink" title="象。Lock提供了比synchronized更多的功能。"></a>象。Lock提供了比synchronized更多的功能。</h4><h4 id="Lock与的Synchronized区别"><a href="#Lock与的Synchronized区别" class="headerlink" title="Lock与的Synchronized区别"></a>Lock与的Synchronized区别</h4><ul>
<li>Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内</li>
</ul>
<h4 id="置特性。Lock是一个类，通过这个类可以实现同步访问；"><a href="#置特性。Lock是一个类，通过这个类可以实现同步访问；" class="headerlink" title="置特性。Lock是一个类，通过这个类可以实现同步访问；"></a>置特性。Lock是一个类，通过这个类可以实现同步访问；</h4><ul>
<li>Lock和synchronized有一点非常大的不同，采用synchronized不需要用户</li>
</ul>
<h4 id="去手动释放锁，当-synchronized-方法或者-synchronized-代码块执行完之后，"><a href="#去手动释放锁，当-synchronized-方法或者-synchronized-代码块执行完之后，" class="headerlink" title="去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，"></a>去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，</h4><h4 id="系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如"><a href="#系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如" class="headerlink" title="系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如"></a>系统会自动让线程释放对锁的占用；而Lock则必须要用户去手动释放锁，如</h4><h4 id="果没有主动释放锁，就有可能导致出现死锁现象。"><a href="#果没有主动释放锁，就有可能导致出现死锁现象。" class="headerlink" title="果没有主动释放锁，就有可能导致出现死锁现象。"></a>果没有主动释放锁，就有可能导致出现死锁现象。</h4><h4 id="2-2-1-Lock接口"><a href="#2-2-1-Lock接口" class="headerlink" title="2.2.1 Lock接口"></a>2.2.1 Lock接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface Lock &#123;</span><br><span class="line">void lock();</span><br><span class="line">void lockInterruptibly() throws InterruptedException;</span><br><span class="line">boolean tryLock();</span><br><span class="line">boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</span><br><span class="line">void unlock();</span><br><span class="line">Condition newCondition();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="下面来逐个讲述Lock接口中每个方法的使用"><a href="#下面来逐个讲述Lock接口中每个方法的使用" class="headerlink" title="下面来逐个讲述Lock接口中每个方法的使用"></a>下面来逐个讲述Lock接口中每个方法的使用</h4><h4 id="2-2-2-lock"><a href="#2-2-2-lock" class="headerlink" title="2.2.2 lock"></a>2.2.2 lock</h4><h4 id="lock-方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他"><a href="#lock-方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他" class="headerlink" title="lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他"></a>lock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他</h4><h4 id="线程获取，则进行等待。"><a href="#线程获取，则进行等待。" class="headerlink" title="线程获取，则进行等待。"></a>线程获取，则进行等待。</h4><h4 id="采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一"><a href="#采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一" class="headerlink" title="采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一"></a>采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一</h4><h4 id="般来说，使用Lock必须在try-catch-块中进行，并且将释放锁的操作放在"><a href="#般来说，使用Lock必须在try-catch-块中进行，并且将释放锁的操作放在" class="headerlink" title="般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在"></a>般来说，使用Lock必须在try{}catch{}块中进行，并且将释放锁的操作放在</h4><h4 id="finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock"><a href="#finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock" class="headerlink" title="finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock"></a>finally块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用Lock</h4><h4 id="来进行同步的话，是以下面这种形式去使用的："><a href="#来进行同步的话，是以下面这种形式去使用的：" class="headerlink" title="来进行同步的话，是以下面这种形式去使用的："></a>来进行同步的话，是以下面这种形式去使用的：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line">try&#123;</span><br><span class="line">//处理任务</span><br><span class="line">&#125;catch(Exception ex)&#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;finally&#123;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock.unlock(); //释放锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-newCondition"><a href="#2-2-3-newCondition" class="headerlink" title="2.2. 3 newCondition"></a>2.2. 3 newCondition</h4><h4 id="关键字synchronized与wait-x2F-notify-这两个方法一起使用可以实现等待-x2F-通"><a href="#关键字synchronized与wait-x2F-notify-这两个方法一起使用可以实现等待-x2F-通" class="headerlink" title="关键字synchronized与wait()&#x2F;notify()这两个方法一起使用可以实现等待&#x2F;通"></a>关键字synchronized与wait()&#x2F;notify()这两个方法一起使用可以实现等待&#x2F;通</h4><h4 id="知模式，-Lock锁的newContition-方法返回Condition对象，Condition类"><a href="#知模式，-Lock锁的newContition-方法返回Condition对象，Condition类" class="headerlink" title="知模式， Lock锁的newContition()方法返回Condition对象，Condition类"></a>知模式， Lock锁的newContition()方法返回Condition对象，Condition类</h4><h4 id="也可以实现等待-x2F-通知模式。"><a href="#也可以实现等待-x2F-通知模式。" class="headerlink" title="也可以实现等待&#x2F;通知模式。"></a>也可以实现等待&#x2F;通知模式。</h4><h4 id="用notify-通知时，JVM会随机唤醒某个等待的线程，-使用Condition类可以"><a href="#用notify-通知时，JVM会随机唤醒某个等待的线程，-使用Condition类可以" class="headerlink" title="用notify()通知时，JVM会随机唤醒某个等待的线程， 使用Condition类可以"></a>用notify()通知时，JVM会随机唤醒某个等待的线程， 使用Condition类可以</h4><h4 id="进行选择性通知，-Condition比较常用的两个方法："><a href="#进行选择性通知，-Condition比较常用的两个方法：" class="headerlink" title="进行选择性通知， Condition比较常用的两个方法："></a>进行选择性通知， Condition比较常用的两个方法：</h4><ul>
<li>await()会使当前线程等待,同时会释放锁,当其他线程调用signal()时,线程会重</li>
</ul>
<h4 id="新获得锁并继续执行。"><a href="#新获得锁并继续执行。" class="headerlink" title="新获得锁并继续执行。"></a>新获得锁并继续执行。</h4><ul>
<li>signal()用于唤醒一个等待的线程。</li>
</ul>
<h4 id="x3D-x3D-注意：在调用Condition的await-x2F-signal-方法前，也需要线程持有相关"><a href="#x3D-x3D-注意：在调用Condition的await-x2F-signal-方法前，也需要线程持有相关" class="headerlink" title="&#x3D;&#x3D;注意：在调用Condition的await()&#x2F;signal()方法前，也需要线程持有相关"></a>&#x3D;&#x3D;注意：在调用Condition的await()&#x2F;signal()方法前，也需要线程持有相关</h4><h4 id="的Lock锁，调用await-后线程会释放这个锁，在singal-调用后会从当前"><a href="#的Lock锁，调用await-后线程会释放这个锁，在singal-调用后会从当前" class="headerlink" title="的Lock锁，调用await()后线程会释放这个锁，在singal()调用后会从当前"></a>的Lock锁，调用await()后线程会释放这个锁，在singal()调用后会从当前</h4><h4 id="Condition对象的等待队列中，唤醒-一个线程，唤醒的线程尝试获得锁，-一旦"><a href="#Condition对象的等待队列中，唤醒-一个线程，唤醒的线程尝试获得锁，-一旦" class="headerlink" title="Condition对象的等待队列中，唤醒 一个线程，唤醒的线程尝试获得锁， 一旦"></a>Condition对象的等待队列中，唤醒 一个线程，唤醒的线程尝试获得锁， 一旦</h4><h4 id="获得锁成功就继续执行。-x3D-x3D"><a href="#获得锁成功就继续执行。-x3D-x3D" class="headerlink" title="获得锁成功就继续执行。&#x3D;&#x3D;"></a>获得锁成功就继续执行。&#x3D;&#x3D;</h4><h4 id="2-3-ReentrantLock"><a href="#2-3-ReentrantLock" class="headerlink" title="2.3 ReentrantLock"></a>2.3 ReentrantLock</h4><h4 id="ReentrantLock，意思是“可重入锁”，关于可重入锁的概念将在后面讲述。"><a href="#ReentrantLock，意思是“可重入锁”，关于可重入锁的概念将在后面讲述。" class="headerlink" title="ReentrantLock，意思是“可重入锁”，关于可重入锁的概念将在后面讲述。"></a>ReentrantLock，意思是“可重入锁”，关于可重入锁的概念将在后面讲述。</h4><h4 id="ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更"><a href="#ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更" class="headerlink" title="ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更"></a>ReentrantLock是唯一实现了Lock接口的类，并且ReentrantLock提供了更</h4><h4 id="多的方法。下面通过一些实例看具体看一下如何使用。"><a href="#多的方法。下面通过一些实例看具体看一下如何使用。" class="headerlink" title="多的方法。下面通过一些实例看具体看一下如何使用。"></a>多的方法。下面通过一些实例看具体看一下如何使用。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">private ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">final Test test = new Test();</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">new Thread()&#123;</span><br><span class="line">public void run() &#123;</span><br><span class="line">test.insert(Thread.currentThread());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>}.start();</p>
<p>new Thread(){<br>public void run() {<br>test.insert(Thread.currentThread());<br>};<br>}.start();<br>}</p>
<p>public void insert(Thread thread) {<br>Lock lock &#x3D; new ReentrantLock(); &#x2F;&#x2F;注意这个地方<br>lock.lock();<br>try {<br>System.out.println(thread.getName()+”得到了锁”);<br>for(int i&#x3D; 0 ;i&lt; 5 ;i++) {<br>arrayList.add(i);<br>}<br>} catch (Exception e) {<br>&#x2F;&#x2F; TODO: handle exception<br>}finally {<br>System.out.println(thread.getName()+”释放了锁”);<br>lock.unlock();<br>}<br>}<br>}</p>
<h4 id="2-4-ReadWriteLock"><a href="#2-4-ReadWriteLock" class="headerlink" title="2.4 ReadWriteLock"></a>2.4 ReadWriteLock</h4><h4 id="ReadWriteLock也是一个接口，在它里面只定义了两个方法："><a href="#ReadWriteLock也是一个接口，在它里面只定义了两个方法：" class="headerlink" title="ReadWriteLock也是一个接口，在它里面只定义了两个方法："></a>ReadWriteLock也是一个接口，在它里面只定义了两个方法：</h4><p>public interface ReadWriteLock {</p>
<p>&#x2F;**</p>
<ul>
<li><p>Returns the lock used for reading.</p>
</li>
<li></li>
<li><p>@return the lock used for reading.</p>
</li>
</ul>
<p>*&#x2F;</p>
<p>Lock readLock();</p>
<h5 id="x2F"><a href="#x2F" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><ul>
<li><p>Returns the lock used for writing.</p>
</li>
<li></li>
<li><p>@return the lock used for writing.</p>
</li>
</ul>
<p>*&#x2F;</p>
<p>Lock writeLock();</p>
<p>}</p>
<h4 id="一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分"><a href="#一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分" class="headerlink" title="一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分"></a>一个用来获取读锁，一个用来获取写锁。也就是说将文件的读写操作分开，分</h4><h4 id="成-2-个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的"><a href="#成-2-个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的" class="headerlink" title="成 2 个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的"></a>成 2 个锁来分配给线程，从而使得多个线程可以同时进行读操作。下面的</h4><h4 id="ReentrantReadWriteLock-实现了ReadWriteLock接口。"><a href="#ReentrantReadWriteLock-实现了ReadWriteLock接口。" class="headerlink" title="ReentrantReadWriteLock 实现了ReadWriteLock接口。"></a>ReentrantReadWriteLock 实现了ReadWriteLock接口。</h4><h4 id="ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个"><a href="#ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个" class="headerlink" title="ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个"></a>ReentrantReadWriteLock里面提供了很多丰富的方法，不过最主要的有两个</h4><h4 id="方法：readLock-和writeLock-用来获取读锁和写锁。"><a href="#方法：readLock-和writeLock-用来获取读锁和写锁。" class="headerlink" title="方法：readLock()和writeLock()用来获取读锁和写锁。"></a>方法：readLock()和writeLock()用来获取读锁和写锁。</h4><h4 id="下面通过几个例子来看一下ReentrantReadWriteLock具体用法。"><a href="#下面通过几个例子来看一下ReentrantReadWriteLock具体用法。" class="headerlink" title="下面通过几个例子来看一下ReentrantReadWriteLock具体用法。"></a>下面通过几个例子来看一下ReentrantReadWriteLock具体用法。</h4><h4 id="假如有多个线程要同时进行读操作的话，先看一下-synchronized-达到的效果："><a href="#假如有多个线程要同时进行读操作的话，先看一下-synchronized-达到的效果：" class="headerlink" title="假如有多个线程要同时进行读操作的话，先看一下 synchronized 达到的效果："></a>假如有多个线程要同时进行读操作的话，先看一下 synchronized 达到的效果：</h4><h4 id="public-class-Test"><a href="#public-class-Test" class="headerlink" title="public class Test {"></a>public class Test {</h4><h4 id="private-ReentrantReadWriteLock-rwl-x3D-new"><a href="#private-ReentrantReadWriteLock-rwl-x3D-new" class="headerlink" title="private ReentrantReadWriteLock rwl &#x3D; new"></a>private ReentrantReadWriteLock rwl &#x3D; new</h4><h4 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock();"></a>ReentrantReadWriteLock();</h4><h4 id="public-static-void-main-String-args"><a href="#public-static-void-main-String-args" class="headerlink" title="public static void main(String[] args) {"></a>public static void main(String[] args) {</h4><h4 id="final-Test-test-x3D-new-Test"><a href="#final-Test-test-x3D-new-Test" class="headerlink" title="final Test test &#x3D; new Test();"></a>final Test test &#x3D; new Test();</h4><h4 id="new-Thread"><a href="#new-Thread" class="headerlink" title="new Thread(){"></a>new Thread(){</h4><h4 id="public-void-run"><a href="#public-void-run" class="headerlink" title="public void run() {"></a>public void run() {</h4><h4 id="test-get-Thread-currentThread"><a href="#test-get-Thread-currentThread" class="headerlink" title="test.get(Thread.currentThread());"></a>test.get(Thread.currentThread());</h4><h4 id=""><a href="#" class="headerlink" title="};"></a>};</h4><h4 id="start"><a href="#start" class="headerlink" title="}.start();"></a>}.start();</h4><h4 id="new-Thread-1"><a href="#new-Thread-1" class="headerlink" title="new Thread(){"></a>new Thread(){</h4><h4 id="public-void-run-1"><a href="#public-void-run-1" class="headerlink" title="public void run() {"></a>public void run() {</h4><h4 id="test-get-Thread-currentThread-1"><a href="#test-get-Thread-currentThread-1" class="headerlink" title="test.get(Thread.currentThread());"></a>test.get(Thread.currentThread());</h4><h4 id="-1"><a href="#-1" class="headerlink" title="};"></a>};</h4><h4 id="start-1"><a href="#start-1" class="headerlink" title="}.start();"></a>}.start();</h4><h4 id="-2"><a href="#-2" class="headerlink" title="}"></a>}</h4><h4 id="public-synchronized-void-get-Thread-thread"><a href="#public-synchronized-void-get-Thread-thread" class="headerlink" title="public synchronized void get(Thread thread) {"></a>public synchronized void get(Thread thread) {</h4><h4 id="long-start-x3D-System-currentTimeMillis"><a href="#long-start-x3D-System-currentTimeMillis" class="headerlink" title="long start &#x3D; System.currentTimeMillis();"></a>long start &#x3D; System.currentTimeMillis();</h4><h4 id="while-System-currentTimeMillis-start-lt-x3D-1"><a href="#while-System-currentTimeMillis-start-lt-x3D-1" class="headerlink" title="while(System.currentTimeMillis() - start &lt;&#x3D; 1) {"></a>while(System.currentTimeMillis() - start &lt;&#x3D; 1) {</h4><h4 id="System-out-println-thread-getName-”正在进行读操作”"><a href="#System-out-println-thread-getName-”正在进行读操作”" class="headerlink" title="System.out.println(thread.getName()+”正在进行读操作”);"></a>System.out.println(thread.getName()+”正在进行读操作”);</h4><h4 id="-3"><a href="#-3" class="headerlink" title="}"></a>}</h4><h4 id="System-out-println-thread-getName-”读操作完毕”"><a href="#System-out-println-thread-getName-”读操作完毕”" class="headerlink" title="System.out.println(thread.getName()+”读操作完毕”);"></a>System.out.println(thread.getName()+”读操作完毕”);</h4><h4 id="-4"><a href="#-4" class="headerlink" title="}"></a>}</h4><h4 id="-5"><a href="#-5" class="headerlink" title="}"></a>}</h4><h4 id="而改成用读写锁的话："><a href="#而改成用读写锁的话：" class="headerlink" title="而改成用读写锁的话："></a>而改成用读写锁的话：</h4><h4 id="public-class-Test-1"><a href="#public-class-Test-1" class="headerlink" title="public class Test {"></a>public class Test {</h4><h4 id="private-ReentrantReadWriteLock-rwl-x3D-new-1"><a href="#private-ReentrantReadWriteLock-rwl-x3D-new-1" class="headerlink" title="private ReentrantReadWriteLock rwl &#x3D; new"></a>private ReentrantReadWriteLock rwl &#x3D; new</h4><h4 id="ReentrantReadWriteLock-1"><a href="#ReentrantReadWriteLock-1" class="headerlink" title="ReentrantReadWriteLock();"></a>ReentrantReadWriteLock();</h4><h4 id="public-static-void-main-String-args-1"><a href="#public-static-void-main-String-args-1" class="headerlink" title="public static void main(String[] args) {"></a>public static void main(String[] args) {</h4><h4 id="final-Test-test-x3D-new-Test-1"><a href="#final-Test-test-x3D-new-Test-1" class="headerlink" title="final Test test &#x3D; new Test();"></a>final Test test &#x3D; new Test();</h4><h4 id="new-Thread-2"><a href="#new-Thread-2" class="headerlink" title="new Thread(){"></a>new Thread(){</h4><h4 id="public-void-run-2"><a href="#public-void-run-2" class="headerlink" title="public void run() {"></a>public void run() {</h4><h4 id="test-get-Thread-currentThread-2"><a href="#test-get-Thread-currentThread-2" class="headerlink" title="test.get(Thread.currentThread());"></a>test.get(Thread.currentThread());</h4><h4 id="-6"><a href="#-6" class="headerlink" title="};"></a>};</h4><h4 id="start-2"><a href="#start-2" class="headerlink" title="}.start();"></a>}.start();</h4><h4 id="new-Thread-3"><a href="#new-Thread-3" class="headerlink" title="new Thread(){"></a>new Thread(){</h4><h4 id="public-void-run-3"><a href="#public-void-run-3" class="headerlink" title="public void run() {"></a>public void run() {</h4><h4 id="test-get-Thread-currentThread-3"><a href="#test-get-Thread-currentThread-3" class="headerlink" title="test.get(Thread.currentThread());"></a>test.get(Thread.currentThread());</h4><h4 id="-7"><a href="#-7" class="headerlink" title="};"></a>};</h4><h4 id="start-3"><a href="#start-3" class="headerlink" title="}.start();"></a>}.start();</h4><h4 id="-8"><a href="#-8" class="headerlink" title="}"></a>}</h4><h4 id="public-void-get-Thread-thread"><a href="#public-void-get-Thread-thread" class="headerlink" title="public void get(Thread thread) {"></a>public void get(Thread thread) {</h4><h4 id="rwl-readLock-lock"><a href="#rwl-readLock-lock" class="headerlink" title="rwl.readLock().lock();"></a>rwl.readLock().lock();</h4><h4 id="try"><a href="#try" class="headerlink" title="try {"></a>try {</h4><h4 id="long-start-x3D-System-currentTimeMillis-1"><a href="#long-start-x3D-System-currentTimeMillis-1" class="headerlink" title="long start &#x3D; System.currentTimeMillis();"></a>long start &#x3D; System.currentTimeMillis();</h4><h4 id="while-System-currentTimeMillis-start-lt-x3D-1-1"><a href="#while-System-currentTimeMillis-start-lt-x3D-1-1" class="headerlink" title="while(System.currentTimeMillis() - start &lt;&#x3D; 1) {"></a>while(System.currentTimeMillis() - start &lt;&#x3D; 1) {</h4><h4 id="System-out-println-thread-getName-”正在进行读操作”-1"><a href="#System-out-println-thread-getName-”正在进行读操作”-1" class="headerlink" title="System.out.println(thread.getName()+”正在进行读操作”);"></a>System.out.println(thread.getName()+”正在进行读操作”);</h4><h4 id="-9"><a href="#-9" class="headerlink" title="}"></a>}</h4><h4 id="System-out-println-thread-getName-”读操作完毕”-1"><a href="#System-out-println-thread-getName-”读操作完毕”-1" class="headerlink" title="System.out.println(thread.getName()+”读操作完毕”);"></a>System.out.println(thread.getName()+”读操作完毕”);</h4><h4 id="finally"><a href="#finally" class="headerlink" title="} finally {"></a>} finally {</h4><h4 id="rwl-readLock-unlock"><a href="#rwl-readLock-unlock" class="headerlink" title="rwl.readLock().unlock();"></a>rwl.readLock().unlock();</h4><h4 id="-10"><a href="#-10" class="headerlink" title="}"></a>}</h4><h4 id="-11"><a href="#-11" class="headerlink" title="}"></a>}</h4><h4 id="-12"><a href="#-12" class="headerlink" title="}"></a>}</h4><h4 id="说明thread1和thread2在同时进行读操作。这样就大大提升了读操作的效率。"><a href="#说明thread1和thread2在同时进行读操作。这样就大大提升了读操作的效率。" class="headerlink" title="说明thread1和thread2在同时进行读操作。这样就大大提升了读操作的效率。"></a>说明thread1和thread2在同时进行读操作。这样就大大提升了读操作的效率。</h4><h4 id="x3D-x3D-注意-x3D-x3D"><a href="#x3D-x3D-注意-x3D-x3D" class="headerlink" title="&#x3D;&#x3D; 注意: &#x3D;&#x3D;"></a>&#x3D;&#x3D; 注意: &#x3D;&#x3D;</h4><ul>
<li>如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写</li>
</ul>
<h4 id="锁的线程会一直等待释放读锁。"><a href="#锁的线程会一直等待释放读锁。" class="headerlink" title="锁的线程会一直等待释放读锁。"></a>锁的线程会一直等待释放读锁。</h4><ul>
<li>如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则</li>
</ul>
<h4 id="申请的线程会一直等待释放写锁。"><a href="#申请的线程会一直等待释放写锁。" class="headerlink" title="申请的线程会一直等待释放写锁。"></a>申请的线程会一直等待释放写锁。</h4><h4 id="2-5-小结-重点"><a href="#2-5-小结-重点" class="headerlink" title="2.5 小结(重点)"></a>2.5 小结(重点)</h4><h4 id="Lock和synchronized有以下几点不同："><a href="#Lock和synchronized有以下几点不同：" class="headerlink" title="Lock和synchronized有以下几点不同："></a>Lock和synchronized有以下几点不同：</h4><h4 id="1-Lock是一个接口，而synchronized是Java中的关键字，synchronized是内"><a href="#1-Lock是一个接口，而synchronized是Java中的关键字，synchronized是内" class="headerlink" title="1. Lock是一个接口，而synchronized是Java中的关键字，synchronized是内"></a>1. Lock是一个接口，而synchronized是Java中的关键字，synchronized是内</h4><h4 id="置的语言实现；"><a href="#置的语言实现；" class="headerlink" title="置的语言实现；"></a>置的语言实现；</h4><h4 id="2-synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现"><a href="#2-synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现" class="headerlink" title="2. synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现"></a>2. synchronized在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现</h4><h4 id="象发生；而Lock在发生异常时，如果没有主动通过unLock-去释放锁，则很"><a href="#象发生；而Lock在发生异常时，如果没有主动通过unLock-去释放锁，则很" class="headerlink" title="象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很"></a>象发生；而Lock在发生异常时，如果没有主动通过unLock()去释放锁，则很</h4><h4 id="可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；"><a href="#可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；" class="headerlink" title="可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；"></a>可能造成死锁现象，因此使用Lock时需要在finally块中释放锁；</h4><h4 id="3-Lock可以让等待锁的线程响应中断，而synchronized却不行，使用"><a href="#3-Lock可以让等待锁的线程响应中断，而synchronized却不行，使用" class="headerlink" title="3. Lock可以让等待锁的线程响应中断，而synchronized却不行，使用"></a>3. Lock可以让等待锁的线程响应中断，而synchronized却不行，使用</h4><h4 id="synchronized时，等待的线程会一直等待下去，不能够响应中断；"><a href="#synchronized时，等待的线程会一直等待下去，不能够响应中断；" class="headerlink" title="synchronized时，等待的线程会一直等待下去，不能够响应中断；"></a>synchronized时，等待的线程会一直等待下去，不能够响应中断；</h4><h4 id="4-通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。"><a href="#4-通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。" class="headerlink" title="4. 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。"></a>4. 通过Lock可以知道有没有成功获取锁，而synchronized却无法办到。</h4><h4 id="5-Lock可以提高多个线程进行读操作的效率。"><a href="#5-Lock可以提高多个线程进行读操作的效率。" class="headerlink" title="5. Lock可以提高多个线程进行读操作的效率。"></a>5. Lock可以提高多个线程进行读操作的效率。</h4><h4 id="在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源"><a href="#在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源" class="headerlink" title="在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源"></a>在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源</h4><h4 id="非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于"><a href="#非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于" class="headerlink" title="非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于"></a>非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于</h4><h4 id="synchronized。"><a href="#synchronized。" class="headerlink" title="synchronized。"></a>synchronized。</h4><h1 id="3-线程间通信"><a href="#3-线程间通信" class="headerlink" title="3 线程间通信"></a>3 线程间通信</h1><h4 id="线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模"><a href="#线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模" class="headerlink" title="线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模"></a>线程间通信的模型有两种：共享内存和消息传递，以下方式都是基本这两种模</h4><h4 id="型来实现的。我们来基本一道面试常见的题目来分析"><a href="#型来实现的。我们来基本一道面试常见的题目来分析" class="headerlink" title="型来实现的。我们来基本一道面试常见的题目来分析"></a>型来实现的。我们来基本一道面试常见的题目来分析</h4><h4 id="场景—两个线程，一个线程对当前数值加-1-，另一个线程对当前数值减1-要求"><a href="#场景—两个线程，一个线程对当前数值加-1-，另一个线程对当前数值减1-要求" class="headerlink" title="场景—两个线程，一个线程对当前数值加 1 ，另一个线程对当前数值减1,要求"></a>场景—两个线程，一个线程对当前数值加 1 ，另一个线程对当前数值减1,要求</h4><h4 id="用线程间通信"><a href="#用线程间通信" class="headerlink" title="用线程间通信"></a>用线程间通信</h4><h2 id="3-1-synchronized方案"><a href="#3-1-synchronized方案" class="headerlink" title="3. 1 synchronized方案"></a>3. 1 synchronized方案</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">package com.atguigu.test;</span><br></pre></td></tr></table></figure>
<h5 id="x2F-1"><a href="#x2F-1" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* volatile关键字实现线程交替加减</span><br><span class="line">*/</span><br><span class="line">public class TestVolatile &#123;</span><br><span class="line">/**</span><br><span class="line">* 交替加减</span><br><span class="line">* @param args</span><br><span class="line">*/</span><br><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">DemoClass demoClass = new DemoClass();</span><br><span class="line">new Thread(() -&gt;&#123;</span><br><span class="line">for (int i = 0; i &lt; 5; i++) &#123;</span><br></pre></td></tr></table></figure>

<p>demoClass.increment();</p>
<p>}</p>
<p>}, “线程A”).start();</p>
<p>new Thread(() -&gt;{</p>
<p>for (int i &#x3D; 0; i &lt; 5; i++) {</p>
<p>demoClass.decrement();</p>
<p>}</p>
<p>}, “线程B”).start();</p>
<p>}</p>
<p>}</p>
<p>package com.atguigu.test;</p>
<p>class DemoClass{</p>
<p>&#x2F;&#x2F;加减对象</p>
<p>private int number &#x3D; 0;</p>
<h5 id="x2F-2"><a href="#x2F-2" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="加-1"><a href="#加-1" class="headerlink" title="* 加 1"></a>* 加 1</h5><h5 id="x2F-3"><a href="#x2F-3" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h5><p>public synchronized void increment() {</p>
<p>try {</p>
<p>while (number !&#x3D; 0){</p>
<p>this.wait();</p>
<p>}</p>
<p>number++;</p>
<p>System.out.println(“——–” + Thread.currentThread().getName() + “加一成<br>功———-,值为:” + number);</p>
<p>notifyAll();</p>
<p>}catch (Exception e){</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<h5 id="x2F-4"><a href="#x2F-4" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="减一"><a href="#减一" class="headerlink" title="* 减一"></a>* 减一</h5><h5 id="x2F-5"><a href="#x2F-5" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h5><p>public synchronized void decrement(){</p>
<p>try {</p>
<p>while (number &#x3D;&#x3D; 0){</p>
<p>this.wait();</p>
<p>}</p>
<p>number–;</p>
<p>System.out.println(“——–” + Thread.currentThread().getName() + “减一成<br>功———-,值为:” + number);</p>
<p>notifyAll();</p>
<p>}catch (Exception e){</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<h2 id="3-2-Lock方案"><a href="#3-2-Lock方案" class="headerlink" title="3. 2 Lock方案"></a>3. 2 Lock方案</h2><p>package com.atguigu.test;</p>
<p>import java.util.concurrent.locks.Condition;</p>
<p>import java.util.concurrent.locks.Lock;</p>
<p>import java.util.concurrent.locks.ReentrantLock;</p>
<p>class DemoClass{</p>
<p>&#x2F;&#x2F;加减对象</p>
<p>private int number &#x3D; 0;</p>
<h5 id="x2F-x2F-声明锁"><a href="#x2F-x2F-声明锁" class="headerlink" title="&#x2F;&#x2F;声明锁"></a>&#x2F;&#x2F;声明锁</h5><p>private Lock lock &#x3D; new ReentrantLock();</p>
<h5 id="x2F-x2F-声明钥匙"><a href="#x2F-x2F-声明钥匙" class="headerlink" title="&#x2F;&#x2F;声明钥匙"></a>&#x2F;&#x2F;声明钥匙</h5><p>private Condition condition &#x3D; lock.newCondition();</p>
<h5 id="x2F-6"><a href="#x2F-6" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="加-1-1"><a href="#加-1-1" class="headerlink" title="* 加 1"></a>* 加 1</h5><h5 id="x2F-7"><a href="#x2F-7" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h5><p>public void increment() {</p>
<p>try {</p>
<p>lock.lock();</p>
<p>while (number !&#x3D; 0){</p>
<p>condition.await();</p>
<p>}</p>
<p>number++;</p>
<p>System.out.println(“——–” + Thread.currentThread().getName() + “加一成<br>功———-,值为:” + number);</p>
<p>condition.signalAll();</p>
<p>}catch (Exception e){</p>
<p>e.printStackTrace();</p>
<p>}finally {</p>
<p>lock.unlock();</p>
<p>}</p>
<p>}</p>
<h5 id="x2F-8"><a href="#x2F-8" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="减一-1"><a href="#减一-1" class="headerlink" title="* 减一"></a>* 减一</h5><h5 id="x2F-9"><a href="#x2F-9" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h5><p>public void decrement(){</p>
<p>try {</p>
<p>lock.lock();</p>
<p>while (number &#x3D;&#x3D; 0){</p>
<p>condition.await();</p>
<p>}</p>
<p>number–;</p>
<p>System.out.println(“——–” + Thread.currentThread().getName() + “减一成<br>功———-,值为:” + number);</p>
<p>condition.signalAll();</p>
<p>}catch (Exception e){</p>
<p>e.printStackTrace();</p>
<p>}finally {</p>
<p>lock.unlock();</p>
<h5 id="-13"><a href="#-13" class="headerlink" title="}"></a>}</h5><h5 id="-14"><a href="#-14" class="headerlink" title="}"></a>}</h5><h5 id="-15"><a href="#-15" class="headerlink" title="}"></a>}</h5><h2 id="3-4-线程间定制化通信"><a href="#3-4-线程间定制化通信" class="headerlink" title="3 .4 线程间定制化通信"></a>3 .4 线程间定制化通信</h2><h3 id="4-4-1-案例介绍"><a href="#4-4-1-案例介绍" class="headerlink" title="4.4.1 案例介绍"></a>4.4.1 案例介绍</h3><h4 id="x3D-x3D-问题-A线程打印-5-次A，B线程打印-10-次B，C线程打印-15-次C-按照"><a href="#x3D-x3D-问题-A线程打印-5-次A，B线程打印-10-次B，C线程打印-15-次C-按照" class="headerlink" title="&#x3D;&#x3D; 问题: A线程打印 5 次A，B线程打印 10 次B，C线程打印 15 次C,按照"></a>&#x3D;&#x3D; 问题: A线程打印 5 次A，B线程打印 10 次B，C线程打印 15 次C,按照</h4><h4 id="此顺序循环-10-轮-x3D-x3D"><a href="#此顺序循环-10-轮-x3D-x3D" class="headerlink" title="此顺序循环 10 轮 &#x3D;&#x3D;"></a>此顺序循环 10 轮 &#x3D;&#x3D;</h4><h3 id="4-4-2-实现流程"><a href="#4-4-2-实现流程" class="headerlink" title="4.4.2 实现流程"></a>4.4.2 实现流程</h3><p>package com.atguigu.test;</p>
<p>import java.util.concurrent.locks.Condition;</p>
<p>import java.util.concurrent.locks.Lock;</p>
<p>import java.util.concurrent.locks.ReentrantLock;</p>
<p>class DemoClass{</p>
<p>&#x2F;&#x2F;通信对象:0–打印A 1—打印B 2—-打印C</p>
<p>private int number &#x3D; 0;</p>
<p>&#x2F;&#x2F;声明锁</p>
<p>private Lock lock &#x3D; new ReentrantLock();</p>
<p>&#x2F;&#x2F;声明钥匙A</p>
<p>private Condition conditionA &#x3D; lock.newCondition();</p>
<p>&#x2F;&#x2F;声明钥匙B</p>
<p>private Condition conditionB &#x3D; lock.newCondition();</p>
<p>&#x2F;&#x2F;声明钥匙C</p>
<p>private Condition conditionC &#x3D; lock.newCondition();</p>
<h5 id="x2F-10"><a href="#x2F-10" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="A打印-5-次"><a href="#A打印-5-次" class="headerlink" title="* A打印 5 次"></a>* A打印 5 次</h5><h5 id="x2F-11"><a href="#x2F-11" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h5><p>public void printA(int j){</p>
<p>try {</p>
<p>lock.lock();</p>
<p>while (number !&#x3D; 0){</p>
<p>conditionA.await();</p>
<p>}</p>
<p>System.out.println(Thread.currentThread().getName() + “输出A,第” + j + “<br>轮开始”);</p>
<p>&#x2F;&#x2F;输出 5 次A</p>
<p>for (int i &#x3D; 0; i &lt; 5; i++) {</p>
<p>System.out.println(“A”);</p>
<p>}</p>
<p>&#x2F;&#x2F;开始打印B</p>
<p>number &#x3D; 1;</p>
<p>&#x2F;&#x2F;唤醒B</p>
<p>conditionB.signal();</p>
<p>}catch (Exception e){</p>
<p>e.printStackTrace();</p>
<p>}finally {</p>
<p>lock.unlock();</p>
<p>}</p>
<p>}</p>
<h5 id="x2F-12"><a href="#x2F-12" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="B打印-10-次"><a href="#B打印-10-次" class="headerlink" title="* B打印 10 次"></a>* B打印 10 次</h5><h5 id="x2F-13"><a href="#x2F-13" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h5><p>public void printB(int j){</p>
<p>try {</p>
<p>lock.lock();</p>
<p>while (number !&#x3D; 1){</p>
<p>conditionB.await();</p>
<p>}</p>
<p>System.out.println(Thread.currentThread().getName() + “输出B,第” + j + “<br>轮开始”);</p>
<p>&#x2F;&#x2F;输出 10 次B</p>
<p>for (int i &#x3D; 0; i &lt; 10; i++) {</p>
<p>System.out.println(“B”);</p>
<p>}</p>
<p>&#x2F;&#x2F;开始打印C</p>
<p>number &#x3D; 2;</p>
<p>&#x2F;&#x2F;唤醒C</p>
<p>conditionC.signal();</p>
<p>}catch (Exception e){</p>
<p>e.printStackTrace();</p>
<p>}finally {</p>
<p>lock.unlock();</p>
<p>}</p>
<p>}</p>
<h5 id="x2F-14"><a href="#x2F-14" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="C打印-15-次"><a href="#C打印-15-次" class="headerlink" title="* C打印 15 次"></a>* C打印 15 次</h5><h5 id="x2F-15"><a href="#x2F-15" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h5><p>public void printC(int j){</p>
<p>try {</p>
<p>lock.lock();</p>
<p>while (number !&#x3D; 2){</p>
<p>conditionC.await();</p>
<p>}</p>
<p>System.out.println(Thread.currentThread().getName() + “输出C,第” + j + “<br>轮开始”);</p>
<p>&#x2F;&#x2F;输出 15 次C</p>
<p>for (int i &#x3D; 0; i &lt; 15; i++) {</p>
<p>System.out.println(“C”);</p>
<p>}</p>
<p>System.out.println(“—————————————–”);</p>
<p>&#x2F;&#x2F;开始打印A</p>
<p>number &#x3D; 0;</p>
<p>&#x2F;&#x2F;唤醒A</p>
<p>conditionA.signal();</p>
<p>}catch (Exception e){</p>
<p>e.printStackTrace();</p>
<p>}finally {</p>
<p>lock.unlock();</p>
<p>}</p>
<h5 id="-16"><a href="#-16" class="headerlink" title="}"></a>}</h5><h5 id="-17"><a href="#-17" class="headerlink" title="}"></a>}</h5><h5 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h5><p>package com.atguigu.test;</p>
<h5 id="x2F-16"><a href="#x2F-16" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><ul>
<li>volatile关键字实现线程交替加减</li>
</ul>
<p>*&#x2F;</p>
<p>public class TestVolatile {</p>
<p>&#x2F;**</p>
<ul>
<li><p>交替加减</p>
</li>
<li><p>@param args</p>
</li>
</ul>
<p>*&#x2F;</p>
<p>public static void main(String[] args){</p>
<p>DemoClass demoClass &#x3D; new DemoClass();</p>
<p>new Thread(() -&gt;{</p>
<p>for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) {</p>
<p>demoClass.printA(i);</p>
<p>}</p>
<p>}, “A线程”).start();</p>
<p>new Thread(() -&gt;{</p>
<p>for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) {</p>
<p>demoClass.printB(i);</p>
<p>}</p>
<p>}, “B线程”).start();</p>
<p>new Thread(() -&gt;{</p>
<p>for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) {</p>
<p>demoClass.printC(i);</p>
<p>}</p>
<p>}, “C线程”).start();</p>
<p>}</p>
<p>}</p>
<h1 id="4-集合的线程安全"><a href="#4-集合的线程安全" class="headerlink" title="4 集合的线程安全"></a>4 集合的线程安全</h1><h2 id="4-1-集合操作Demo"><a href="#4-1-集合操作Demo" class="headerlink" title="4 .1 集合操作Demo"></a>4 .1 集合操作Demo</h2><p>NotSafeDemo</p>
<p>package com.atguigu.test;</p>
<p>import java.util.ArrayList;<br>import java.util.List;<br>import java.util.UUID;</p>
<p>&#x2F;**</p>
<h5 id="集合线程安全案例"><a href="#集合线程安全案例" class="headerlink" title="* 集合线程安全案例"></a>* 集合线程安全案例</h5><h5 id="x2F-17"><a href="#x2F-17" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h5><p>public class NotSafeDemo {</p>
<p>&#x2F;**</p>
<ul>
<li>多个线程同时对集合进行修改</li>
<li>@param args<br>*&#x2F;<br>public static void main(String[] args) {<br>List list &#x3D; new ArrayList();</li>
</ul>
<p>for (int i &#x3D; 0 ; i &lt; 100 ; i++) {<br>new Thread(() -&gt;{<br>list.add(UUID.randomUUID().toString());<br>System.out.println(list);<br>}, “线程” + i).start();<br>}<br>}<br>}</p>
<p>异常内容</p>
<p>java.util.ConcurrentModificationException</p>
<p><strong>问题: 为什么会出现并发修改异常?</strong></p>
<p>查看ArrayList的add方法源码</p>
<p>&#x2F;**</p>
<ul>
<li>Appends the specified element to the end of this list.</li>
<li></li>
<li>@param e element to be appended to this list</li>
<li>@return <tt>true</tt> (as specified by {@link Collection#add})<br>*&#x2F;<br>public boolean add(E e) {<br>ensureCapacityInternal(size + 1 ); &#x2F;&#x2F; Increments modCount!!<br>elementData[size++] &#x3D; e;<br>return true;<br>}</li>
</ul>
<h4 id="x3D-x3D-那么我们如何去解决List类型的线程安全问题-x3D-x3D"><a href="#x3D-x3D-那么我们如何去解决List类型的线程安全问题-x3D-x3D" class="headerlink" title="&#x3D;&#x3D; 那么我们如何去解决List类型的线程安全问题? &#x3D;&#x3D;"></a>&#x3D;&#x3D; 那么我们如何去解决List类型的线程安全问题? &#x3D;&#x3D;</h4><h2 id="4-2-Vector"><a href="#4-2-Vector" class="headerlink" title="4 .2 Vector"></a>4 .2 Vector</h2><h4 id="Vector-是-矢量队列-，它是JDK1-0版本添加的类。继承于AbstractList，实现"><a href="#Vector-是-矢量队列-，它是JDK1-0版本添加的类。继承于AbstractList，实现" class="headerlink" title="Vector 是 矢量队列 ，它是JDK1.0版本添加的类。继承于AbstractList，实现"></a>Vector 是 矢量队列 ，它是JDK1.0版本添加的类。继承于AbstractList，实现</h4><h4 id="了List-RandomAccess-Cloneable这些接口。-Vector-继承了AbstractList，"><a href="#了List-RandomAccess-Cloneable这些接口。-Vector-继承了AbstractList，" class="headerlink" title="了List, RandomAccess, Cloneable这些接口。 Vector 继承了AbstractList，"></a>了List, RandomAccess, Cloneable这些接口。 Vector 继承了AbstractList，</h4><h4 id="实现了List；所以，-它是一个队列，支持相关的添加、删除、修改、遍历等功"><a href="#实现了List；所以，-它是一个队列，支持相关的添加、删除、修改、遍历等功" class="headerlink" title="实现了List；所以， 它是一个队列，支持相关的添加、删除、修改、遍历等功"></a>实现了List；所以， 它是一个队列，支持相关的添加、删除、修改、遍历等功</h4><h4 id="能-。-Vector-实现了RandmoAccess接口，即-提供了随机访问功能-。"><a href="#能-。-Vector-实现了RandmoAccess接口，即-提供了随机访问功能-。" class="headerlink" title="能 。 Vector 实现了RandmoAccess接口，即 提供了随机访问功能 。"></a>能 。 Vector 实现了RandmoAccess接口，即 提供了随机访问功能 。</h4><h4 id="RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在"><a href="#RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在" class="headerlink" title="RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在"></a>RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在</h4><h4 id="Vector中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访"><a href="#Vector中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访" class="headerlink" title="Vector中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访"></a>Vector中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访</h4><h4 id="问。-Vector-实现了Cloneable接口，即实现clone-函数。它能被克隆。"><a href="#问。-Vector-实现了Cloneable接口，即实现clone-函数。它能被克隆。" class="headerlink" title="问。 Vector 实现了Cloneable接口，即实现clone()函数。它能被克隆。"></a>问。 Vector 实现了Cloneable接口，即实现clone()函数。它能被克隆。</h4><h4 id="x3D-x3D-和ArrayList不同，Vector中的操作是线程安全的。-x3D-x3D"><a href="#x3D-x3D-和ArrayList不同，Vector中的操作是线程安全的。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D;和ArrayList不同，Vector中的操作是线程安全的。&#x3D;&#x3D;"></a>&#x3D;&#x3D;和ArrayList不同，Vector中的操作是线程安全的。&#x3D;&#x3D;</h4><h4 id="NotSafeDemo代码修改"><a href="#NotSafeDemo代码修改" class="headerlink" title="NotSafeDemo代码修改"></a>NotSafeDemo代码修改</h4><p>package com.atguigu.test;</p>
<p>import java.util.ArrayList;<br>import java.util.List;<br>import java.util.UUID;<br>import java.util.Vector;</p>
<p>&#x2F;**</p>
<ul>
<li>集合线程安全案例<br>*&#x2F;<br>public class NotSafeDemo {</li>
</ul>
<p>&#x2F;**</p>
<ul>
<li>多个线程同时对集合进行修改</li>
<li>@param args<br>*&#x2F;<br>public static void main(String[] args) {<br>List list &#x3D; new Vector();</li>
</ul>
<p>for (int i &#x3D; 0 ; i &lt; 100 ; i++) {<br>new Thread(() -&gt;{<br>list.add(UUID.randomUUID().toString());</p>
<p>System.out.println(list);<br>}, “线程” + i).start();<br>}<br>}<br>}</p>
<h4 id="现在没有运行出现并发异常-为什么"><a href="#现在没有运行出现并发异常-为什么" class="headerlink" title="现在没有运行出现并发异常,为什么?"></a>现在没有运行出现并发异常,为什么?</h4><h4 id="查看Vector的add方法"><a href="#查看Vector的add方法" class="headerlink" title="查看Vector的add方法"></a>查看Vector的add方法</h4><h5 id="x2F-18"><a href="#x2F-18" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><ul>
<li>Appends the specified element to the end of this Vector.</li>
<li></li>
<li>@param e element to be appended to this Vector</li>
<li>@return {@code true} (as specified by {@link Collection#add})</li>
<li>@since 1.2<br>*&#x2F;<br>public synchronized boolean add(E e) {<br>modCount++;<br>ensureCapacityHelper(elementCount + 1 );<br>elementData[elementCount++] &#x3D; e;<br>return true;</li>
</ul>
<h4 id="-18"><a href="#-18" class="headerlink" title="}"></a>}</h4><h4 id="add方法被synchronized同步修辞-线程安全-因此没有并发异常"><a href="#add方法被synchronized同步修辞-线程安全-因此没有并发异常" class="headerlink" title="add方法被synchronized同步修辞,线程安全!因此没有并发异常"></a>add方法被synchronized同步修辞,线程安全!因此没有并发异常</h4><h2 id="4-3-Collections"><a href="#4-3-Collections" class="headerlink" title="4 .3 Collections"></a>4 .3 Collections</h2><h4 id="Collections提供了方法synchronizedList保证list是同步线程安全的"><a href="#Collections提供了方法synchronizedList保证list是同步线程安全的" class="headerlink" title="Collections提供了方法synchronizedList保证list是同步线程安全的"></a>Collections提供了方法synchronizedList保证list是同步线程安全的</h4><h4 id="NotSafeDemo代码修改-1"><a href="#NotSafeDemo代码修改-1" class="headerlink" title="NotSafeDemo代码修改"></a>NotSafeDemo代码修改</h4><p>package com.atguigu.test;</p>
<p>import java.util.*;</p>
<p>&#x2F;**</p>
<ul>
<li>集合线程安全案例<br>*&#x2F;</li>
</ul>
<p>public class NotSafeDemo {</p>
<p>&#x2F;**</p>
<ul>
<li>多个线程同时对集合进行修改</li>
<li>@param args<br>*&#x2F;<br>public static void main(String[] args) {<br>List list &#x3D; Collections.synchronizedList(new ArrayList&lt;&gt;());<br>for (int i &#x3D; 0 ; i &lt; 100 ; i++) {<br>new Thread(() -&gt;{<br>list.add(UUID.randomUUID().toString());<br>System.out.println(list);<br>}, “线程” + i).start();<br>}<br>}<br>}</li>
</ul>
<p>没有并发修改异常</p>
<p>查看方法源码</p>
<p>&#x2F;**</p>
<ul>
<li>Returns a synchronized (thread-safe) list backed by the specified</li>
<li>list. In order to guarantee serial access, it is critical that</li>
<li><strong>all</strong> access to the backing list is accomplished</li>
<li>through the returned list.<p></li>
<li></li>
<li>It is imperative that the user manually synchronize on the returned</li>
<li>list when iterating over it:</li>
<li><pre></li>
<li>List list &#x3D; Collections.synchronizedList(new ArrayList());</li>
<li>…</li>
<li>synchronized (list) {</li>
<li>Iterator i &#x3D; list.iterator(); &#x2F;&#x2F; Must be in synchronized block</li>
<li>while (i.hasNext())</li>
<li>foo(i.next());</li>
<li>}</li>
<li></pre></li>
<li>Failure to follow this advice may result in non-deterministic behavior.</li>
</ul>
<h5 id="-19"><a href="#-19" class="headerlink" title="*"></a>*</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* &lt;p&gt;The returned list will be serializable if the specified list is</span><br><span class="line">* serializable.</span><br><span class="line">*</span><br><span class="line">* @param &lt;T&gt; the class of the objects in the list</span><br><span class="line">* @param list the list to be &quot;wrapped&quot; in a synchronized list.</span><br><span class="line">* @return a synchronized view of the specified list.</span><br><span class="line">*/</span><br><span class="line">public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123;</span><br><span class="line">return (list instanceof RandomAccess?</span><br><span class="line">new SynchronizedRandomAccessList&lt;&gt;(list) :</span><br><span class="line">new SynchronizedList&lt;&gt;(list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-CopyOnWriteArrayList-重点"><a href="#4-4-CopyOnWriteArrayList-重点" class="headerlink" title="4 .4 CopyOnWriteArrayList(重点)"></a>4 .4 CopyOnWriteArrayList(重点)</h2><h4 id="首先我们对CopyOnWriteArrayList进行学习-其特点如下"><a href="#首先我们对CopyOnWriteArrayList进行学习-其特点如下" class="headerlink" title="首先我们对CopyOnWriteArrayList进行学习,其特点如下:"></a>首先我们对CopyOnWriteArrayList进行学习,其特点如下:</h4><h4 id="它相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和"><a href="#它相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和" class="headerlink" title="它相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和"></a>它相当于线程安全的ArrayList。和ArrayList一样，它是个可变数组；但是和</h4><h4 id="ArrayList不同的时，它具有以下特性："><a href="#ArrayList不同的时，它具有以下特性：" class="headerlink" title="ArrayList不同的时，它具有以下特性："></a>ArrayList不同的时，它具有以下特性：</h4><h4 id="1-它最适合于具有以下特征的应用程序：List-大小通常保持很小，只读操作远多"><a href="#1-它最适合于具有以下特征的应用程序：List-大小通常保持很小，只读操作远多" class="headerlink" title="1. 它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多"></a>1. 它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多</h4><h4 id="于可变操作，需要在遍历期间防止线程间的冲突。"><a href="#于可变操作，需要在遍历期间防止线程间的冲突。" class="headerlink" title="于可变操作，需要在遍历期间防止线程间的冲突。"></a>于可变操作，需要在遍历期间防止线程间的冲突。</h4><h4 id="2-它是线程安全的。"><a href="#2-它是线程安全的。" class="headerlink" title="2. 它是线程安全的。"></a>2. 它是线程安全的。</h4><h4 id="3-因为通常需要复制整个基础数组，所以可变操作（add-、set-和-remove"><a href="#3-因为通常需要复制整个基础数组，所以可变操作（add-、set-和-remove" class="headerlink" title="3. 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove()"></a>3. 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove()</h4><h4 id="等等）的开销很大。"><a href="#等等）的开销很大。" class="headerlink" title="等等）的开销很大。"></a>等等）的开销很大。</h4><h4 id="4-迭代器支持-hasNext-next-等不可变操作，但不支持可变-remove-等操作。"><a href="#4-迭代器支持-hasNext-next-等不可变操作，但不支持可变-remove-等操作。" class="headerlink" title="4. 迭代器支持 hasNext(), next()等不可变操作，但不支持可变 remove()等操作。"></a>4. 迭代器支持 hasNext(), next()等不可变操作，但不支持可变 remove()等操作。</h4><h4 id="5-使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代"><a href="#5-使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代" class="headerlink" title="5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代"></a>5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代</h4><h4 id="器时，迭代器依赖于不变的数组快照。"><a href="#器时，迭代器依赖于不变的数组快照。" class="headerlink" title="器时，迭代器依赖于不变的数组快照。"></a>器时，迭代器依赖于不变的数组快照。</h4><h4 id="1-独占锁效率低：采用读写分离思想解决"><a href="#1-独占锁效率低：采用读写分离思想解决" class="headerlink" title="1. 独占锁效率低：采用读写分离思想解决"></a>1. 独占锁效率低：采用读写分离思想解决</h4><h4 id="2-写线程获取到锁，其他写线程阻塞"><a href="#2-写线程获取到锁，其他写线程阻塞" class="headerlink" title="2. 写线程获取到锁，其他写线程阻塞"></a>2. 写线程获取到锁，其他写线程阻塞</h4><h4 id="3-复制思想："><a href="#3-复制思想：" class="headerlink" title="3. 复制思想："></a>3. 复制思想：</h4><h4 id="当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容"><a href="#当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容" class="headerlink" title="当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容"></a>当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容</h4><h4 id="器进行-Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素"><a href="#器进行-Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素" class="headerlink" title="器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素"></a>器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素</h4><h4 id="之后，再将原容器的引用指向新的容器。"><a href="#之后，再将原容器的引用指向新的容器。" class="headerlink" title="之后，再将原容器的引用指向新的容器。"></a>之后，再将原容器的引用指向新的容器。</h4><h4 id="这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来"><a href="#这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来" class="headerlink" title="这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来"></a>这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来</h4><h4 id="得及写会内存，其他的线程就会读到了脏数据。"><a href="#得及写会内存，其他的线程就会读到了脏数据。" class="headerlink" title="得及写会内存，其他的线程就会读到了脏数据。"></a>得及写会内存，其他的线程就会读到了脏数据。</h4><h4 id="x3D-x3D-这就是CopyOnWriteArrayList-的思想和原理。就是拷贝一份。-x3D-x3D"><a href="#x3D-x3D-这就是CopyOnWriteArrayList-的思想和原理。就是拷贝一份。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D; 这就是CopyOnWriteArrayList 的思想和原理。就是拷贝一份。 &#x3D;&#x3D;"></a>&#x3D;&#x3D; 这就是CopyOnWriteArrayList 的思想和原理。就是拷贝一份。 &#x3D;&#x3D;</h4><h4 id="NotSafeDemo代码修改-2"><a href="#NotSafeDemo代码修改-2" class="headerlink" title="NotSafeDemo代码修改"></a>NotSafeDemo代码修改</h4><h4 id="package-com-atguigu-test"><a href="#package-com-atguigu-test" class="headerlink" title="package com.atguigu.test;"></a>package com.atguigu.test;</h4><h4 id="import-java-util"><a href="#import-java-util" class="headerlink" title="import java.util.*;"></a>import java.util.*;</h4><h4 id="import-java-util-concurrent-CopyOnWriteArrayList"><a href="#import-java-util-concurrent-CopyOnWriteArrayList" class="headerlink" title="import java.util.concurrent.CopyOnWriteArrayList;"></a>import java.util.concurrent.CopyOnWriteArrayList;</h4><h4 id="x2F-19"><a href="#x2F-19" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h4><h4 id="集合线程安全案例-1"><a href="#集合线程安全案例-1" class="headerlink" title="* 集合线程安全案例"></a>* 集合线程安全案例</h4><h4 id="x2F-20"><a href="#x2F-20" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h4><h4 id="public-class-NotSafeDemo"><a href="#public-class-NotSafeDemo" class="headerlink" title="public class NotSafeDemo {"></a>public class NotSafeDemo {</h4><h4 id="x2F-21"><a href="#x2F-21" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h4><h4 id="多个线程同时对集合进行修改"><a href="#多个线程同时对集合进行修改" class="headerlink" title="* 多个线程同时对集合进行修改"></a>* 多个线程同时对集合进行修改</h4><h4 id="param-args"><a href="#param-args" class="headerlink" title="* @param args"></a>* @param args</h4><h4 id="x2F-22"><a href="#x2F-22" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h4><h4 id="public-static-void-main-String-args-2"><a href="#public-static-void-main-String-args-2" class="headerlink" title="public static void main(String[] args) {"></a>public static void main(String[] args) {</h4><h4 id="List-list-x3D-new-CopyOnWriteArrayList"><a href="#List-list-x3D-new-CopyOnWriteArrayList" class="headerlink" title="List list &#x3D; new CopyOnWriteArrayList();"></a>List list &#x3D; new CopyOnWriteArrayList();</h4><h4 id="for-int-i-x3D-0-i-lt-100-i"><a href="#for-int-i-x3D-0-i-lt-100-i" class="headerlink" title="for (int i &#x3D; 0 ; i &lt; 100 ; i++) {"></a>for (int i &#x3D; 0 ; i &lt; 100 ; i++) {</h4><h4 id="new-Thread-gt"><a href="#new-Thread-gt" class="headerlink" title="new Thread(() -&gt;{"></a>new Thread(() -&gt;{</h4><h4 id="list-add-UUID-randomUUID-toString"><a href="#list-add-UUID-randomUUID-toString" class="headerlink" title="list.add(UUID.randomUUID().toString());"></a>list.add(UUID.randomUUID().toString());</h4><h4 id="System-out-println-list"><a href="#System-out-println-list" class="headerlink" title="System.out.println(list);"></a>System.out.println(list);</h4><h4 id="“线程”-i-start"><a href="#“线程”-i-start" class="headerlink" title="}, “线程” + i).start();"></a>}, “线程” + i).start();</h4><h4 id="-20"><a href="#-20" class="headerlink" title="}"></a>}</h4><h4 id="-21"><a href="#-21" class="headerlink" title="}"></a>}</h4><h4 id="-22"><a href="#-22" class="headerlink" title="}"></a>}</h4><h4 id="没有线程安全问题"><a href="#没有线程安全问题" class="headerlink" title="没有线程安全问题"></a>没有线程安全问题</h4><h4 id="原因分析-重点-x3D-x3D-动态数组与线程安全-x3D-x3D"><a href="#原因分析-重点-x3D-x3D-动态数组与线程安全-x3D-x3D" class="headerlink" title="原因分析 ( 重点 ):&#x3D;&#x3D; 动态数组与线程安全 &#x3D;&#x3D;"></a>原因分析 ( 重点 ):&#x3D;&#x3D; 动态数组与线程安全 &#x3D;&#x3D;</h4><h4 id="下面从“动态数组”和“线程安全”两个方面进一步对"><a href="#下面从“动态数组”和“线程安全”两个方面进一步对" class="headerlink" title="下面从“动态数组”和“线程安全”两个方面进一步对"></a>下面从“动态数组”和“线程安全”两个方面进一步对</h4><h4 id="CopyOnWriteArrayList的原理进行说明。"><a href="#CopyOnWriteArrayList的原理进行说明。" class="headerlink" title="CopyOnWriteArrayList的原理进行说明。"></a>CopyOnWriteArrayList的原理进行说明。</h4><ul>
<li><strong>“动态数组”机制</strong></li>
</ul>
<h4 id="o-它内部有个“volatile数组”-array-来保持数据。在“添加-x2F-修改-x2F-删除”数据"><a href="#o-它内部有个“volatile数组”-array-来保持数据。在“添加-x2F-修改-x2F-删除”数据" class="headerlink" title="o 它内部有个“volatile数组”(array)来保持数据。在“添加&#x2F;修改&#x2F;删除”数据"></a>o 它内部有个“volatile数组”(array)来保持数据。在“添加&#x2F;修改&#x2F;删除”数据</h4><h4 id="时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该"><a href="#时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该" class="headerlink" title="时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该"></a>时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该</h4><h4 id="数组赋值给“volatile数组”-这就是它叫做CopyOnWriteArrayList的原因"><a href="#数组赋值给“volatile数组”-这就是它叫做CopyOnWriteArrayList的原因" class="headerlink" title="数组赋值给“volatile数组”, 这就是它叫做CopyOnWriteArrayList的原因"></a>数组赋值给“volatile数组”, 这就是它叫做CopyOnWriteArrayList的原因</h4><h4 id="o-由于它在“添加-x2F-修改-x2F-删除”数据时，都会新建数组，所以涉及到修改数据的"><a href="#o-由于它在“添加-x2F-修改-x2F-删除”数据时，都会新建数组，所以涉及到修改数据的" class="headerlink" title="o 由于它在“添加&#x2F;修改&#x2F;删除”数据时，都会新建数组，所以涉及到修改数据的"></a>o 由于它在“添加&#x2F;修改&#x2F;删除”数据时，都会新建数组，所以涉及到修改数据的</h4><h4 id="操作，CopyOnWriteArrayList效率很低；但是单单只是进行遍历查找的话，"><a href="#操作，CopyOnWriteArrayList效率很低；但是单单只是进行遍历查找的话，" class="headerlink" title="操作，CopyOnWriteArrayList效率很低；但是单单只是进行遍历查找的话，"></a>操作，CopyOnWriteArrayList效率很低；但是单单只是进行遍历查找的话，</h4><h4 id="效率比较高。"><a href="#效率比较高。" class="headerlink" title="效率比较高。"></a>效率比较高。</h4><ul>
<li><strong>“线程安全”机制</strong></li>
</ul>
<h4 id="o-通过volatile和互斥锁来实现的。"><a href="#o-通过volatile和互斥锁来实现的。" class="headerlink" title="o 通过volatile和互斥锁来实现的。"></a>o 通过volatile和互斥锁来实现的。</h4><h4 id="o-通过“volatile数组”来保存数据的。一个线程读取volatile数组时，总能看"><a href="#o-通过“volatile数组”来保存数据的。一个线程读取volatile数组时，总能看" class="headerlink" title="o 通过“volatile数组”来保存数据的。一个线程读取volatile数组时，总能看"></a>o 通过“volatile数组”来保存数据的。一个线程读取volatile数组时，总能看</h4><h4 id="到其它线程对该volatile变量最后的写入；就这样，通过volatile提供了“读"><a href="#到其它线程对该volatile变量最后的写入；就这样，通过volatile提供了“读" class="headerlink" title="到其它线程对该volatile变量最后的写入；就这样，通过volatile提供了“读"></a>到其它线程对该volatile变量最后的写入；就这样，通过volatile提供了“读</h4><h4 id="取到的数据总是最新的”这个机制的保证。"><a href="#取到的数据总是最新的”这个机制的保证。" class="headerlink" title="取到的数据总是最新的”这个机制的保证。"></a>取到的数据总是最新的”这个机制的保证。</h4><h4 id="o-通过互斥锁来保护数据。在“添加-x2F-修改-x2F-删除”数据时，会先“获取互斥锁”，"><a href="#o-通过互斥锁来保护数据。在“添加-x2F-修改-x2F-删除”数据时，会先“获取互斥锁”，" class="headerlink" title="o 通过互斥锁来保护数据。在“添加&#x2F;修改&#x2F;删除”数据时，会先“获取互斥锁”，"></a>o 通过互斥锁来保护数据。在“添加&#x2F;修改&#x2F;删除”数据时，会先“获取互斥锁”，</h4><h4 id="再修改完毕之后，先将数据更新到“volatile数组”中，然后再“释放互斥"><a href="#再修改完毕之后，先将数据更新到“volatile数组”中，然后再“释放互斥" class="headerlink" title="再修改完毕之后，先将数据更新到“volatile数组”中，然后再“释放互斥"></a>再修改完毕之后，先将数据更新到“volatile数组”中，然后再“释放互斥</h4><h4 id="锁”，就达到了保护数据的目的。"><a href="#锁”，就达到了保护数据的目的。" class="headerlink" title="锁”，就达到了保护数据的目的。"></a>锁”，就达到了保护数据的目的。</h4><h2 id="4-5-小结-重点"><a href="#4-5-小结-重点" class="headerlink" title="4 .5 小结(重点)"></a>4 .5 小结(重点)</h2><h4 id="1-线程安全与线程不安全集合"><a href="#1-线程安全与线程不安全集合" class="headerlink" title="1.线程安全与线程不安全集合"></a>1.线程安全与线程不安全集合</h4><h4 id="集合类型中存在线程安全与线程不安全的两种-常见例如"><a href="#集合类型中存在线程安全与线程不安全的两种-常见例如" class="headerlink" title="集合类型中存在线程安全与线程不安全的两种,常见例如:"></a>集合类型中存在线程安全与线程不安全的两种,常见例如:</h4><h4 id="ArrayList-—–-Vector"><a href="#ArrayList-—–-Vector" class="headerlink" title="ArrayList —– Vector"></a>ArrayList —– Vector</h4><h4 id="HashMap-—–HashTable"><a href="#HashMap-—–HashTable" class="headerlink" title="HashMap —–HashTable"></a>HashMap —–HashTable</h4><h4 id="但是以上都是通过synchronized关键字实现-效率较低"><a href="#但是以上都是通过synchronized关键字实现-效率较低" class="headerlink" title="但是以上都是通过synchronized关键字实现,效率较低"></a>但是以上都是通过synchronized关键字实现,效率较低</h4><h4 id="2-Collections构建的线程安全集合"><a href="#2-Collections构建的线程安全集合" class="headerlink" title="2.Collections构建的线程安全集合"></a>2.Collections构建的线程安全集合</h4><h4 id="3-java-util-concurrent并发包下"><a href="#3-java-util-concurrent并发包下" class="headerlink" title="3.java.util.concurrent并发包下"></a>3.java.util.concurrent并发包下</h4><h4 id="CopyOnWriteArrayList-CopyOnWriteArraySet类型-通过动态数组与线程安"><a href="#CopyOnWriteArrayList-CopyOnWriteArraySet类型-通过动态数组与线程安" class="headerlink" title="CopyOnWriteArrayList CopyOnWriteArraySet类型,通过动态数组与线程安"></a>CopyOnWriteArrayList CopyOnWriteArraySet类型,通过动态数组与线程安</h4><h4 id="全个方面保证线程安全"><a href="#全个方面保证线程安全" class="headerlink" title="全个方面保证线程安全"></a>全个方面保证线程安全</h4><h1 id="5-多线程锁"><a href="#5-多线程锁" class="headerlink" title="5 多线程锁"></a>5 多线程锁</h1><h2 id="5-1-锁的八个问题演示"><a href="#5-1-锁的八个问题演示" class="headerlink" title="5 .1 锁的八个问题演示"></a>5 .1 锁的八个问题演示</h2><p><strong>class</strong> Phone {</p>
<p><strong>public static synchronized void</strong> sendSMS() <strong>throws</strong> Exception {<br><em>&#x2F;&#x2F;</em> 停留 <em>4</em> 秒<br>TimeUnit. <strong><em>SECONDS</em></strong> .sleep( 4 );<br>System. <strong><em>out</em></strong> .println( <strong>“——sendSMS”</strong> );<br>}</p>
<p><strong>public synchronized void</strong> sendEmail() <strong>throws</strong> Exception {<br>System. <strong><em>out</em></strong> .println( <strong>“——sendEmail”</strong> );<br>}</p>
<p><strong>public void</strong> getHello() {<br>System. <strong><em>out</em></strong> .println( <strong>“——getHello”</strong> );<br>}<br>}<br>&#x2F;**</p>
<ul>
<li><strong>@Description:</strong> 8 锁</li>
<li>1 标准访问，先打印短信还是邮件<br>——sendSMS<br>——sendEmail</li>
</ul>
<p>2 停 4 秒在短信方法内，先打印短信还是邮件<br>——sendSMS<br>——sendEmail</p>
<p>3 新增普通的hello方法，是先打短信还是hello<br>——getHello<br>——sendSMS</p>
<p>4 现在有两部手机，先打印短信还是邮件<br>——sendEmail<br>——sendSMS</p>
<p>5 两个静态同步方法， 1 部手机，先打印短信还是邮件<br>——sendSMS<br>——sendEmail</p>
<h5 id="6-两个静态同步方法，-2-部手机，先打印短信还是邮件"><a href="#6-两个静态同步方法，-2-部手机，先打印短信还是邮件" class="headerlink" title="6 两个静态同步方法， 2 部手机，先打印短信还是邮件"></a>6 两个静态同步方法， 2 部手机，先打印短信还是邮件</h5><p>——sendSMS<br>——sendEmail</p>
<p>7 1个静态同步方法,1个普通同步方法， 1 部手机，先打印短信还是邮件<br>——sendEmail<br>——sendSMS</p>
<p>8 1个静态同步方法,1个普通同步方法， 2 部手机，先打印短信还是邮件<br>——sendEmail<br>——sendSMS</p>
<p><strong>结论:</strong></p>
<p>一个对象里面如果有多个synchronized方法，某一个时刻内，只要一个线程去调用其中的<br>一个synchronized方法了，<br>其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些<br>synchronized方法<br>锁的是当前对象this，被锁定后，其它的线程都不能进入到当前对象的其它的<br>synchronized方法<br>加个普通方法后发现和同步锁无关<br>换成两个对象后，不是同一把锁了，情况立刻变化。<br>synchronized实现同步的基础：Java中的每一个对象都可以作为锁。<br><strong>具体表现为以下 3 种形式。<br>对于普通同步方法，锁是当前实例对象。<br>对于静态同步方法，锁是当前类的Class对象。<br>对于同步方法块，锁是Synchonized括号里配置的对象</strong><br>当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。<br>也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方<br>法必须等待获取锁的方法释放锁后才能获取锁，<br>可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，<br>所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。<br>所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所<br>以静态同步方法与非静态同步方法之间是不会有竞态条件的。<br>但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才<br>能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同<br>步方法之间，只要它们同一个类的实例对象！</p>
<h1 id="6-Callable-amp-Future-接口"><a href="#6-Callable-amp-Future-接口" class="headerlink" title="6 Callable&amp;Future 接口"></a>6 Callable&amp;Future 接口</h1><h2 id="6-1-Callable接口"><a href="#6-1-Callable接口" class="headerlink" title="6 .1 Callable接口"></a>6 .1 Callable接口</h2><h4 id="目前我们学习了有两种创建线程的方法-一种是通过创建Thread类，另一种是"><a href="#目前我们学习了有两种创建线程的方法-一种是通过创建Thread类，另一种是" class="headerlink" title="目前我们学习了有两种创建线程的方法-一种是通过创建Thread类，另一种是"></a>目前我们学习了有两种创建线程的方法-一种是通过创建Thread类，另一种是</h4><h4 id="通过使用Runnable创建线程。但是，Runnable缺少的一项功能是，当线程"><a href="#通过使用Runnable创建线程。但是，Runnable缺少的一项功能是，当线程" class="headerlink" title="通过使用Runnable创建线程。但是，Runnable缺少的一项功能是，当线程"></a>通过使用Runnable创建线程。但是，Runnable缺少的一项功能是，当线程</h4><h4 id="终止时（即run（）完成时），我们无法使线程返回结果。为了支持此功能，"><a href="#终止时（即run（）完成时），我们无法使线程返回结果。为了支持此功能，" class="headerlink" title="终止时（即run（）完成时），我们无法使线程返回结果。为了支持此功能，"></a>终止时（即run（）完成时），我们无法使线程返回结果。为了支持此功能，</h4><h4 id="Java中提供了Callable接口。"><a href="#Java中提供了Callable接口。" class="headerlink" title="Java中提供了Callable接口。"></a>Java中提供了Callable接口。</h4><h4 id="x3D-x3D-现在我们学习的是创建线程的第三种方案—Callable接口-x3D-x3D"><a href="#x3D-x3D-现在我们学习的是创建线程的第三种方案—Callable接口-x3D-x3D" class="headerlink" title="&#x3D;&#x3D; 现在我们学习的是创建线程的第三种方案—Callable接口 &#x3D;&#x3D;"></a>&#x3D;&#x3D; 现在我们学习的是创建线程的第三种方案—Callable接口 &#x3D;&#x3D;</h4><h4 id="Callable接口的特点如下-重点"><a href="#Callable接口的特点如下-重点" class="headerlink" title="Callable接口的特点如下(重点)"></a>Callable接口的特点如下(重点)</h4><ul>
<li>为了实现Runnable，需要实现不返回任何内容的run（）方法，而对于</li>
</ul>
<h4 id="Callable，需要实现在完成时返回结果的call（）方法。"><a href="#Callable，需要实现在完成时返回结果的call（）方法。" class="headerlink" title="Callable，需要实现在完成时返回结果的call（）方法。"></a>Callable，需要实现在完成时返回结果的call（）方法。</h4><ul>
<li>call（）方法可以引发异常，而run（）则不能。</li>
<li>为实现Callable而必须重写call方法</li>
<li>不能直接替换runnable,因为Thread类的构造方法根本没有Callable</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">创建新类MyThread实现runnable接口</span><br><span class="line">class MyThread implements Runnable&#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">新类MyThread2实现callable接口</span><br><span class="line">class MyThread2 implements Callable&lt;Integer&gt;&#123;</span><br><span class="line">@Override</span><br><span class="line">public Integer call() throws Exception &#123;</span><br><span class="line">return 200 ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-2-Future接口"><a href="#6-2-Future接口" class="headerlink" title="6 .2 Future接口"></a>6 .2 Future接口</h2><h4 id="当call（）方法完成时，结果必须存储在主线程已知的对象中，以便主线程可"><a href="#当call（）方法完成时，结果必须存储在主线程已知的对象中，以便主线程可" class="headerlink" title="当call（）方法完成时，结果必须存储在主线程已知的对象中，以便主线程可"></a>当call（）方法完成时，结果必须存储在主线程已知的对象中，以便主线程可</h4><h4 id="以知道该线程返回的结果。为此，可以使用Future对象。"><a href="#以知道该线程返回的结果。为此，可以使用Future对象。" class="headerlink" title="以知道该线程返回的结果。为此，可以使用Future对象。"></a>以知道该线程返回的结果。为此，可以使用Future对象。</h4><h4 id="将Future视为保存结果的对象–它可能暂时不保存结果，但将来会保存（一旦"><a href="#将Future视为保存结果的对象–它可能暂时不保存结果，但将来会保存（一旦" class="headerlink" title="将Future视为保存结果的对象–它可能暂时不保存结果，但将来会保存（一旦"></a>将Future视为保存结果的对象–它可能暂时不保存结果，但将来会保存（一旦</h4><h4 id="Callable返回）。Future基本上是主线程可以跟踪进度以及其他线程的结果的"><a href="#Callable返回）。Future基本上是主线程可以跟踪进度以及其他线程的结果的" class="headerlink" title="Callable返回）。Future基本上是主线程可以跟踪进度以及其他线程的结果的"></a>Callable返回）。Future基本上是主线程可以跟踪进度以及其他线程的结果的</h4><h4 id="一种方式。要实现此接口，必须重写-5-种方法，这里列出了重要的方法-如下"><a href="#一种方式。要实现此接口，必须重写-5-种方法，这里列出了重要的方法-如下" class="headerlink" title="一种方式。要实现此接口，必须重写 5 种方法，这里列出了重要的方法,如下:"></a>一种方式。要实现此接口，必须重写 5 种方法，这里列出了重要的方法,如下:</h4><ul>
<li><strong>public boolean cancel（boolean mayInterrupt）：</strong> 用于停止任务。</li>
</ul>
<h4 id="x3D-x3D-如果尚未启动，它将停止任务。如果已启动，则仅在mayInterrupt为true"><a href="#x3D-x3D-如果尚未启动，它将停止任务。如果已启动，则仅在mayInterrupt为true" class="headerlink" title="&#x3D;&#x3D;如果尚未启动，它将停止任务。如果已启动，则仅在mayInterrupt为true"></a>&#x3D;&#x3D;如果尚未启动，它将停止任务。如果已启动，则仅在mayInterrupt为true</h4><h4 id="时才会中断任务。-x3D-x3D"><a href="#时才会中断任务。-x3D-x3D" class="headerlink" title="时才会中断任务。&#x3D;&#x3D;"></a>时才会中断任务。&#x3D;&#x3D;</h4><ul>
<li><strong>public Object get（）抛出InterruptedException，ExecutionException：</strong></li>
</ul>
<h4 id="用于获取任务的结果。"><a href="#用于获取任务的结果。" class="headerlink" title="用于获取任务的结果。"></a>用于获取任务的结果。</h4><h4 id="x3D-x3D-如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。"><a href="#x3D-x3D-如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。" class="headerlink" title="&#x3D;&#x3D;如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。"></a>&#x3D;&#x3D;如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。</h4><h4 id="x3D-x3D"><a href="#x3D-x3D" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h4><ul>
<li><strong>public boolean isDone（）：</strong> 如果任务完成，则返回true，否则返回false</li>
</ul>
<h4 id="可以看到Callable和Future做两件事-Callable与Runnable类似，因为它封"><a href="#可以看到Callable和Future做两件事-Callable与Runnable类似，因为它封" class="headerlink" title="可以看到Callable和Future做两件事-Callable与Runnable类似，因为它封"></a>可以看到Callable和Future做两件事-Callable与Runnable类似，因为它封</h4><h4 id="装了要在另一个线程上运行的任务，而Future用于存储从另一个线程获得的结"><a href="#装了要在另一个线程上运行的任务，而Future用于存储从另一个线程获得的结" class="headerlink" title="装了要在另一个线程上运行的任务，而Future用于存储从另一个线程获得的结"></a>装了要在另一个线程上运行的任务，而Future用于存储从另一个线程获得的结</h4><h4 id="果。实际上，future也可以与Runnable一起使用。"><a href="#果。实际上，future也可以与Runnable一起使用。" class="headerlink" title="果。实际上，future也可以与Runnable一起使用。"></a>果。实际上，future也可以与Runnable一起使用。</h4><h4 id="要创建线程，需要Runnable。为了获得结果，需要future。"><a href="#要创建线程，需要Runnable。为了获得结果，需要future。" class="headerlink" title="要创建线程，需要Runnable。为了获得结果，需要future。"></a>要创建线程，需要Runnable。为了获得结果，需要future。</h4><h2 id="6-3-FutureTask"><a href="#6-3-FutureTask" class="headerlink" title="6. 3 FutureTask"></a>6. 3 FutureTask</h2><h4 id="Java库具有具体的FutureTask类型，该类型实现Runnable和Future，并方"><a href="#Java库具有具体的FutureTask类型，该类型实现Runnable和Future，并方" class="headerlink" title="Java库具有具体的FutureTask类型，该类型实现Runnable和Future，并方"></a>Java库具有具体的FutureTask类型，该类型实现Runnable和Future，并方</h4><h4 id="便地将两种功能组合在一起。-可以通过为其构造函数提供Callable来创建"><a href="#便地将两种功能组合在一起。-可以通过为其构造函数提供Callable来创建" class="headerlink" title="便地将两种功能组合在一起。 可以通过为其构造函数提供Callable来创建"></a>便地将两种功能组合在一起。 可以通过为其构造函数提供Callable来创建</h4><h4 id="FutureTask。然后，将FutureTask对象提供给Thread的构造函数以创建"><a href="#FutureTask。然后，将FutureTask对象提供给Thread的构造函数以创建" class="headerlink" title="FutureTask。然后，将FutureTask对象提供给Thread的构造函数以创建"></a>FutureTask。然后，将FutureTask对象提供给Thread的构造函数以创建</h4><h4 id="Thread对象。因此，间接地使用Callable创建线程。"><a href="#Thread对象。因此，间接地使用Callable创建线程。" class="headerlink" title="Thread对象。因此，间接地使用Callable创建线程。"></a>Thread对象。因此，间接地使用Callable创建线程。</h4><h4 id="核心原理-重点"><a href="#核心原理-重点" class="headerlink" title="核心原理:(重点)"></a>核心原理:(重点)</h4><h4 id="在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些"><a href="#在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些" class="headerlink" title="在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些"></a>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些</h4><h4 id="作业交给Future对象在后台完成"><a href="#作业交给Future对象在后台完成" class="headerlink" title="作业交给Future对象在后台完成"></a>作业交给Future对象在后台完成</h4><ul>
<li>当主线程将来需要时，就可以通过Future对象获得后台作业的计算结果或者执</li>
</ul>
<h4 id="行状态"><a href="#行状态" class="headerlink" title="行状态"></a>行状态</h4><ul>
<li>一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去</li>
</ul>
<h4 id="获取结果。"><a href="#获取结果。" class="headerlink" title="获取结果。"></a>获取结果。</h4><ul>
<li>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法</li>
<li>一旦计算完成，就不能再重新开始或取消计算</li>
<li>get方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完</li>
</ul>
<h4 id="成状态，然后会返回结果或者抛出异常"><a href="#成状态，然后会返回结果或者抛出异常" class="headerlink" title="成状态，然后会返回结果或者抛出异常"></a>成状态，然后会返回结果或者抛出异常</h4><ul>
<li>get只计算一次,因此get方法放到最后</li>
</ul>
<h4 id="demo案例"><a href="#demo案例" class="headerlink" title="demo案例"></a>demo案例</h4><h2 id="6-4-使用Callable和Future"><a href="#6-4-使用Callable和Future" class="headerlink" title="6. 4 使用Callable和Future"></a>6. 4 使用Callable和Future</h2><h4 id="CallableDemo案例"><a href="#CallableDemo案例" class="headerlink" title="CallableDemo案例"></a>CallableDemo案例</h4><h5 id="x2F-23"><a href="#x2F-23" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* CallableDemo案列</span><br><span class="line">*/</span><br><span class="line">public class CallableDemo &#123;</span><br></pre></td></tr></table></figure>
<h5 id="x2F-24"><a href="#x2F-24" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 实现runnable接口</span><br><span class="line">*/</span><br><span class="line">static class MyThread1 implements Runnable&#123;</span><br><span class="line">/**</span><br><span class="line">* run方法</span><br><span class="line">*/</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">try &#123;</span><br></pre></td></tr></table></figure>

<p>System.out.println(Thread.currentThread().getName() + “线程进入了run<br>方法”);</p>
<p>}catch (Exception e){</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<h5 id="x2F-25"><a href="#x2F-25" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><ul>
<li>实现callable接口</li>
</ul>
<p>*&#x2F;</p>
<p>static class MyThread2 implements Callable{</p>
<p>&#x2F;**</p>
<ul>
<li><p>call方法</p>
</li>
<li><p>@return</p>
</li>
<li><p>@throws Exception</p>
</li>
</ul>
<p>*&#x2F;</p>
<p>@Override</p>
<p>public Long call() throws Exception {</p>
<p>try {</p>
<p>System.out.println(Thread.currentThread().getName() + “线程进入了call<br>方法,开始准备睡觉”);</p>
<p>Thread.sleep(1000);</p>
<p>System.out.println(Thread.currentThread().getName() + “睡醒了”);</p>
<p>}catch (Exception e){</p>
<p>e.printStackTrace();</p>
<p>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">return System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">//声明runable</span><br><span class="line">Runnable runable = new MyThread1();</span><br><span class="line">//声明callable</span><br><span class="line">Callable callable = new MyThread2();</span><br><span class="line">//future-callable</span><br><span class="line">FutureTask&lt;Long&gt; futureTask2 = new FutureTask(callable);</span><br><span class="line">//线程二</span><br><span class="line">new Thread(futureTask2, &quot;线程二&quot;).start();</span><br><span class="line">for (int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">Long result1 = futureTask2.get();</span><br><span class="line">System.out.println(result1);</span><br><span class="line">&#125;</span><br><span class="line">//线程一</span><br><span class="line">new Thread(runable,&quot;线程一&quot;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-5-小结-重点"><a href="#6-5-小结-重点" class="headerlink" title="6. 5 小结(重点)"></a>6. 5 小结(重点)</h2><ul>
<li>在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些</li>
</ul>
<h4 id="作业交给Future对象在后台完成-当主线程将来需要时，就可以通过Future"><a href="#作业交给Future对象在后台完成-当主线程将来需要时，就可以通过Future" class="headerlink" title="作业交给Future对象在后台完成, 当主线程将来需要时，就可以通过Future"></a>作业交给Future对象在后台完成, 当主线程将来需要时，就可以通过Future</h4><h4 id="对象获得后台作业的计算结果或者执行状态"><a href="#对象获得后台作业的计算结果或者执行状态" class="headerlink" title="对象获得后台作业的计算结果或者执行状态"></a>对象获得后台作业的计算结果或者执行状态</h4><ul>
<li>一般FutureTask多用于耗时的计算，主线程可以在完成自己的任务后，再去</li>
</ul>
<h4 id="获取结果"><a href="#获取结果" class="headerlink" title="获取结果"></a>获取结果</h4><ul>
<li>仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计</li>
</ul>
<h4 id="算完成，就不能再重新开始或取消计算。get方法而获取结果只有在计算完成"><a href="#算完成，就不能再重新开始或取消计算。get方法而获取结果只有在计算完成" class="headerlink" title="算完成，就不能再重新开始或取消计算。get方法而获取结果只有在计算完成"></a>算完成，就不能再重新开始或取消计算。get方法而获取结果只有在计算完成</h4><h4 id="时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异"><a href="#时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异" class="headerlink" title="时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异"></a>时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异</h4><h4 id="常。"><a href="#常。" class="headerlink" title="常。"></a>常。</h4><ul>
<li>只计算一次</li>
</ul>
<h1 id="7-JUC-三大辅助类"><a href="#7-JUC-三大辅助类" class="headerlink" title="7 JUC 三大辅助类"></a>7 JUC 三大辅助类</h1><h4 id="JUC中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过"><a href="#JUC中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过" class="headerlink" title="JUC中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过"></a>JUC中提供了三种常用的辅助类，通过这些辅助类可以很好的解决线程数量过</h4><h4 id="多时Lock锁的频繁操作。这三种辅助类为："><a href="#多时Lock锁的频繁操作。这三种辅助类为：" class="headerlink" title="多时Lock锁的频繁操作。这三种辅助类为："></a>多时Lock锁的频繁操作。这三种辅助类为：</h4><ul>
<li>CountDownLatch: 减少计数</li>
<li>CyclicBarrier: 循环栅栏</li>
<li>Semaphore: 信号灯</li>
</ul>
<h4 id="下面我们分别进行详细的介绍和学习"><a href="#下面我们分别进行详细的介绍和学习" class="headerlink" title="下面我们分别进行详细的介绍和学习"></a>下面我们分别进行详细的介绍和学习</h4><h2 id="7-1-减少计数CountDownLatch"><a href="#7-1-减少计数CountDownLatch" class="headerlink" title="7 .1 减少计数CountDownLatch"></a>7 .1 减少计数CountDownLatch</h2><h4 id="CountDownLatch类可以设置一个计数器，然后通过countDown方法来进行"><a href="#CountDownLatch类可以设置一个计数器，然后通过countDown方法来进行" class="headerlink" title="CountDownLatch类可以设置一个计数器，然后通过countDown方法来进行"></a>CountDownLatch类可以设置一个计数器，然后通过countDown方法来进行</h4><h4 id="减-1-的操作，使用await方法等待计数器不大于-0-，然后继续执行await方法"><a href="#减-1-的操作，使用await方法等待计数器不大于-0-，然后继续执行await方法" class="headerlink" title="减 1 的操作，使用await方法等待计数器不大于 0 ，然后继续执行await方法"></a>减 1 的操作，使用await方法等待计数器不大于 0 ，然后继续执行await方法</h4><h4 id="之后的语句。"><a href="#之后的语句。" class="headerlink" title="之后的语句。"></a>之后的语句。</h4><ul>
<li>CountDownLatch主要有两个方法，当一个或多个线程调用await方法时，这</li>
</ul>
<h4 id="些线程会阻塞"><a href="#些线程会阻塞" class="headerlink" title="些线程会阻塞"></a>些线程会阻塞</h4><ul>
<li>其它线程调用countDown方法会将计数器减1(调用countDown方法的线程</li>
</ul>
<h4 id="不会阻塞"><a href="#不会阻塞" class="headerlink" title="不会阻塞)"></a>不会阻塞)</h4><ul>
<li>当计数器的值变为 0 时，因await方法阻塞的线程会被唤醒，继续执行</li>
</ul>
<h4 id="场景-6个同学陆续离开教室后值班同学才可以关门。"><a href="#场景-6个同学陆续离开教室后值班同学才可以关门。" class="headerlink" title="场景: 6个同学陆续离开教室后值班同学才可以关门。"></a>场景: 6个同学陆续离开教室后值班同学才可以关门。</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CountDownLatchDemo</span><br></pre></td></tr></table></figure>

<p>package com.atguigu.test;</p>
<p>import java.util.concurrent.CountDownLatch;</p>
<h5 id="x2F-26"><a href="#x2F-26" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><ul>
<li>CountDownLatchDemo</li>
</ul>
<p>*&#x2F;</p>
<p>public class CountDownLatchDemo {</p>
<h5 id="x2F-27"><a href="#x2F-27" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="6个同学陆续离开教室后值班同学才可以关门"><a href="#6个同学陆续离开教室后值班同学才可以关门" class="headerlink" title="* 6个同学陆续离开教室后值班同学才可以关门"></a>* 6个同学陆续离开教室后值班同学才可以关门</h5><ul>
<li>@param args</li>
</ul>
<p>*&#x2F;</p>
<p>public static void main(String[] args) throws Exception{</p>
<p>&#x2F;&#x2F;定义一个数值为 6 的计数器</p>
<p>CountDownLatch countDownLatch &#x3D; new CountDownLatch(6);</p>
<h5 id="x2F-x2F-创建-6-个同学"><a href="#x2F-x2F-创建-6-个同学" class="headerlink" title="&#x2F;&#x2F;创建 6 个同学"></a>&#x2F;&#x2F;创建 6 个同学</h5><p>for (int i &#x3D; 1; i &lt;&#x3D; 6; i++) {</p>
<p>new Thread(() -&gt;{</p>
<p>try{</p>
<p>if(Thread.currentThread().getName().equals(“同学6”)){</p>
<p>Thread.sleep(2000);</p>
<p>}</p>
<p>System.out.println(Thread.currentThread().getName() + “离开了”);</p>
<p>&#x2F;&#x2F;计数器减一,不会阻塞</p>
<p>countDownLatch.countDown();</p>
<p>}catch (Exception e){</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}, “同学” + i).start();</p>
<p>}</p>
<p>&#x2F;&#x2F;主线程await休息</p>
<p>System.out.println(“主线程睡觉”);</p>
<p>countDownLatch.await();</p>
<p>&#x2F;&#x2F;全部离开后自动唤醒主线程</p>
<p>System.out.println(“全部离开了,现在的计数器为” +<br>countDownLatch.getCount());</p>
<p>}</p>
<p>}</p>
<h2 id="7-2-循环栅栏CyclicBarrier"><a href="#7-2-循环栅栏CyclicBarrier" class="headerlink" title="7 .2 循环栅栏CyclicBarrier"></a>7 .2 循环栅栏CyclicBarrier</h2><h4 id="CyclicBarrier看英文单词可以看出大概就是循环阻塞的意思，在使用中"><a href="#CyclicBarrier看英文单词可以看出大概就是循环阻塞的意思，在使用中" class="headerlink" title="CyclicBarrier看英文单词可以看出大概就是循环阻塞的意思，在使用中"></a>CyclicBarrier看英文单词可以看出大概就是循环阻塞的意思，在使用中</h4><h4 id="CyclicBarrier的构造方法第一个参数是目标障碍数，每次执行CyclicBarrier一"><a href="#CyclicBarrier的构造方法第一个参数是目标障碍数，每次执行CyclicBarrier一" class="headerlink" title="CyclicBarrier的构造方法第一个参数是目标障碍数，每次执行CyclicBarrier一"></a>CyclicBarrier的构造方法第一个参数是目标障碍数，每次执行CyclicBarrier一</h4><h4 id="次障碍数会加一，如果达到了目标障碍数，才会执行cyclicBarrier-await-之后"><a href="#次障碍数会加一，如果达到了目标障碍数，才会执行cyclicBarrier-await-之后" class="headerlink" title="次障碍数会加一，如果达到了目标障碍数，才会执行cyclicBarrier.await()之后"></a>次障碍数会加一，如果达到了目标障碍数，才会执行cyclicBarrier.await()之后</h4><h4 id="的语句。可以将CyclicBarrier理解为加-1-操作"><a href="#的语句。可以将CyclicBarrier理解为加-1-操作" class="headerlink" title="的语句。可以将CyclicBarrier理解为加 1 操作"></a>的语句。可以将CyclicBarrier理解为加 1 操作</h4><h4 id="场景-集齐-7-颗龙珠就可以召唤神龙"><a href="#场景-集齐-7-颗龙珠就可以召唤神龙" class="headerlink" title="场景: 集齐 7 颗龙珠就可以召唤神龙"></a>场景: 集齐 7 颗龙珠就可以召唤神龙</h4><p>CyclicBarrierDemo</p>
<p>package com.atguigu.test;</p>
<p>import java.util.concurrent.CyclicBarrier;</p>
<h5 id="x2F-28"><a href="#x2F-28" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><ul>
<li>CyclicBarrierDemo案列</li>
</ul>
<p>*&#x2F;</p>
<p>public class CyclicBarrierDemo {</p>
<h5 id="x2F-x2F-定义神龙召唤需要的龙珠总数"><a href="#x2F-x2F-定义神龙召唤需要的龙珠总数" class="headerlink" title="&#x2F;&#x2F;定义神龙召唤需要的龙珠总数"></a>&#x2F;&#x2F;定义神龙召唤需要的龙珠总数</h5><p>private final static int NUMBER &#x3D; 7;</p>
<h5 id="x2F-29"><a href="#x2F-29" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="集齐-7-颗龙珠就可以召唤神龙"><a href="#集齐-7-颗龙珠就可以召唤神龙" class="headerlink" title="* 集齐 7 颗龙珠就可以召唤神龙"></a>* 集齐 7 颗龙珠就可以召唤神龙</h5><ul>
<li>@param args</li>
</ul>
<p>*&#x2F;</p>
<p>public static void main(String[] args) {</p>
<p>&#x2F;&#x2F;定义循环栅栏</p>
<p>CyclicBarrier cyclicBarrier &#x3D; new CyclicBarrier(NUMBER, () -&gt;{</p>
<p>System.out.println(“集齐” + NUMBER + “颗龙珠,现在召唤神龙!!!!!!!!!”);</p>
<p>});</p>
<p>&#x2F;&#x2F;定义 7 个线程分别去收集龙珠</p>
<p>for (int i &#x3D; 1; i &lt;&#x3D; 7; i++) {</p>
<p>new Thread(()-&gt;{</p>
<p>try {</p>
<p>if(Thread.currentThread().getName().equals(“龙珠 3 号”)){</p>
<p>System.out.println(“龙珠 3 号抢夺战开始,孙悟空开启超级赛亚人模式!”);</p>
<p>Thread.sleep(5000);</p>
<p>System.out.println(“龙珠 3 号抢夺战结束,孙悟空打赢了,拿到了龙珠 3<br>号!”);</p>
<p>}else{</p>
<p>System.out.println(Thread.currentThread().getName() + “收集到<br>了!!!!”);</p>
<p>}</p>
<p>cyclicBarrier.await();</p>
<p>}catch (Exception e){</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>}, “龙珠” + i + “号”).start();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<h2 id="7-3-信号灯Semaphore"><a href="#7-3-信号灯Semaphore" class="headerlink" title="7 .3 信号灯Semaphore"></a>7 .3 信号灯Semaphore</h2><h4 id="Semaphore的构造方法中传入的第一个参数是最大信号量（可以看成最大线"><a href="#Semaphore的构造方法中传入的第一个参数是最大信号量（可以看成最大线" class="headerlink" title="Semaphore的构造方法中传入的第一个参数是最大信号量（可以看成最大线"></a>Semaphore的构造方法中传入的第一个参数是最大信号量（可以看成最大线</h4><h4 id="程池），每个信号量初始化为一个最多只能分发一个许可证。使用acquire方"><a href="#程池），每个信号量初始化为一个最多只能分发一个许可证。使用acquire方" class="headerlink" title="程池），每个信号量初始化为一个最多只能分发一个许可证。使用acquire方"></a>程池），每个信号量初始化为一个最多只能分发一个许可证。使用acquire方</h4><h4 id="法获得许可证，release方法释放许可"><a href="#法获得许可证，release方法释放许可" class="headerlink" title="法获得许可证，release方法释放许可"></a>法获得许可证，release方法释放许可</h4><h4 id="场景-抢车位-6部汽车-3-个停车位"><a href="#场景-抢车位-6部汽车-3-个停车位" class="headerlink" title="场景: 抢车位, 6部汽车 3 个停车位"></a>场景: 抢车位, 6部汽车 3 个停车位</h4><h4 id="SemaphoreDemo"><a href="#SemaphoreDemo" class="headerlink" title="SemaphoreDemo"></a>SemaphoreDemo</h4><p>package com.atguigu.test;</p>
<p>import java.util.concurrent.Semaphore;</p>
<h5 id="x2F-30"><a href="#x2F-30" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><ul>
<li>Semaphore案列</li>
</ul>
<p>*&#x2F;</p>
<p>public class SemaphoreDemo {</p>
<h5 id="x2F-31"><a href="#x2F-31" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="抢车位-10部汽车-1-个停车位"><a href="#抢车位-10部汽车-1-个停车位" class="headerlink" title="* 抢车位, 10部汽车 1 个停车位"></a>* 抢车位, 10部汽车 1 个停车位</h5><ul>
<li>@param args</li>
</ul>
<p>*&#x2F;</p>
<p>public static void main(String[] args) throws Exception{</p>
<p>&#x2F;&#x2F;定义 3 个停车位</p>
<p>Semaphore semaphore &#x3D; new Semaphore(1);</p>
<p>&#x2F;&#x2F;模拟 6 辆汽车停车</p>
<p>for (int i &#x3D; 1; i &lt;&#x3D; 10; i++) {</p>
<p>Thread.sleep(100);</p>
<p>&#x2F;&#x2F;停车</p>
<p>new Thread(() -&gt;{</p>
<p>try {</p>
<p>System.out.println(Thread.currentThread().getName() + “找车位ing”);</p>
<p>semaphore.acquire();</p>
<p>System.out.println(Thread.currentThread().getName() + “汽车停车成<br>功!”);</p>
<p>Thread.sleep(10000);</p>
<p>}catch (Exception e){</p>
<p>e.printStackTrace();</p>
<p>}finally {</p>
<p>System.out.println(Thread.currentThread().getName() + “溜了溜了”);</p>
<p>semaphore.release();</p>
<p>}</p>
<p>}, “汽车” + i).start();</p>
<h5 id="-23"><a href="#-23" class="headerlink" title="}"></a>}</h5><h5 id="-24"><a href="#-24" class="headerlink" title="}"></a>}</h5><h5 id="-25"><a href="#-25" class="headerlink" title="}"></a>}</h5><h1 id="8-读写锁"><a href="#8-读写锁" class="headerlink" title="8 读写锁"></a>8 读写锁</h1><h2 id="8-1-读写锁介绍"><a href="#8-1-读写锁介绍" class="headerlink" title="8 .1 读写锁介绍"></a>8 .1 读写锁介绍</h2><h4 id="现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那"><a href="#现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那" class="headerlink" title="现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那"></a>现实中有这样一种场景：对共享资源有读和写的操作，且写操作没有读操作那</h4><h4 id="么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以"><a href="#么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以" class="headerlink" title="么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以"></a>么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以</h4><h4 id="应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，"><a href="#应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，" class="headerlink" title="应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，"></a>应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，</h4><h4 id="就不应该允许其他线程对该资源进行读和写的操作了。"><a href="#就不应该允许其他线程对该资源进行读和写的操作了。" class="headerlink" title="就不应该允许其他线程对该资源进行读和写的操作了。"></a>就不应该允许其他线程对该资源进行读和写的操作了。</h4><h4 id="针对这种场景，-JAVA的并发包提供了读写锁ReentrantReadWriteLock，"><a href="#针对这种场景，-JAVA的并发包提供了读写锁ReentrantReadWriteLock，" class="headerlink" title="针对这种场景， JAVA的并发包提供了读写锁ReentrantReadWriteLock，"></a>针对这种场景， JAVA的并发包提供了读写锁ReentrantReadWriteLock，</h4><h4 id="它表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称"><a href="#它表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称" class="headerlink" title="它表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称"></a>它表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称</h4><h4 id="为排他锁"><a href="#为排他锁" class="headerlink" title="为排他锁"></a>为排他锁</h4><h4 id="1-线程进入读锁的前提条件："><a href="#1-线程进入读锁的前提条件：" class="headerlink" title="1. 线程进入读锁的前提条件："></a>1. 线程进入读锁的前提条件：</h4><ul>
<li>没有其他线程的写锁</li>
<li>没有写请求, 或者&#x3D;&#x3D;有写请求，但调用线程和持有锁的线程是同一个(可重入</li>
</ul>
<h4 id="锁-。-x3D-x3D"><a href="#锁-。-x3D-x3D" class="headerlink" title="锁)。&#x3D;&#x3D;"></a>锁)。&#x3D;&#x3D;</h4><h4 id="2-线程进入写锁的前提条件："><a href="#2-线程进入写锁的前提条件：" class="headerlink" title="2. 线程进入写锁的前提条件："></a>2. 线程进入写锁的前提条件：</h4><ul>
<li>没有其他线程的读锁</li>
<li>没有其他线程的写锁</li>
</ul>
<h4 id="而读写锁有以下三个重要的特性："><a href="#而读写锁有以下三个重要的特性：" class="headerlink" title="而读写锁有以下三个重要的特性："></a>而读写锁有以下三个重要的特性：</h4><h4 id="（-1-）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公"><a href="#（-1-）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公" class="headerlink" title="（ 1 ）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公"></a>（ 1 ）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公</h4><h4 id="平优于公平。"><a href="#平优于公平。" class="headerlink" title="平优于公平。"></a>平优于公平。</h4><h4 id="（-2-）重进入：读锁和写锁都支持线程重进入。"><a href="#（-2-）重进入：读锁和写锁都支持线程重进入。" class="headerlink" title="（ 2 ）重进入：读锁和写锁都支持线程重进入。"></a>（ 2 ）重进入：读锁和写锁都支持线程重进入。</h4><h4 id="（-3-）锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为"><a href="#（-3-）锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为" class="headerlink" title="（ 3 ）锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为"></a>（ 3 ）锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为</h4><h4 id="读锁。"><a href="#读锁。" class="headerlink" title="读锁。"></a>读锁。</h4><h2 id="8-2-ReentrantReadWriteLock"><a href="#8-2-ReentrantReadWriteLock" class="headerlink" title="8 .2 ReentrantReadWriteLock"></a>8 .2 ReentrantReadWriteLock</h2><h4 id="ReentrantReadWriteLock-类的整体结构"><a href="#ReentrantReadWriteLock-类的整体结构" class="headerlink" title="ReentrantReadWriteLock 类的整体结构"></a>ReentrantReadWriteLock 类的整体结构</h4><h4 id="public-class-ReentrantReadWriteLock-implements-ReadWriteLock"><a href="#public-class-ReentrantReadWriteLock-implements-ReadWriteLock" class="headerlink" title="public class ReentrantReadWriteLock implements ReadWriteLock,"></a>public class ReentrantReadWriteLock implements ReadWriteLock,</h4><h4 id="java-io-Serializable"><a href="#java-io-Serializable" class="headerlink" title="java.io.Serializable {"></a>java.io.Serializable {</h4><h4 id="x2F-读锁-x2F"><a href="#x2F-读锁-x2F" class="headerlink" title="&#x2F;** 读锁 *&#x2F;"></a>&#x2F;** 读锁 *&#x2F;</h4><h4 id="private-final-ReentrantReadWriteLock-ReadLock-readerLock"><a href="#private-final-ReentrantReadWriteLock-ReadLock-readerLock" class="headerlink" title="private final ReentrantReadWriteLock.ReadLock readerLock;"></a>private final ReentrantReadWriteLock.ReadLock readerLock;</h4><h4 id="x2F-写锁-x2F"><a href="#x2F-写锁-x2F" class="headerlink" title="&#x2F;** 写锁 *&#x2F;"></a>&#x2F;** 写锁 *&#x2F;</h4><h4 id="private-final-ReentrantReadWriteLock-WriteLock-writerLock"><a href="#private-final-ReentrantReadWriteLock-WriteLock-writerLock" class="headerlink" title="private final ReentrantReadWriteLock.WriteLock writerLock;"></a>private final ReentrantReadWriteLock.WriteLock writerLock;</h4><h4 id="final-Sync-sync"><a href="#final-Sync-sync" class="headerlink" title="final Sync sync;"></a>final Sync sync;</h4><h4 id="x2F-使用默认（非公平）的排序属性创建一个新的"><a href="#x2F-使用默认（非公平）的排序属性创建一个新的" class="headerlink" title="&#x2F;** 使用默认（非公平）的排序属性创建一个新的"></a>&#x2F;** 使用默认（非公平）的排序属性创建一个新的</h4><h4 id="ReentrantReadWriteLock-x2F"><a href="#ReentrantReadWriteLock-x2F" class="headerlink" title="ReentrantReadWriteLock *&#x2F;"></a>ReentrantReadWriteLock *&#x2F;</h4><h4 id="public-ReentrantReadWriteLock"><a href="#public-ReentrantReadWriteLock" class="headerlink" title="public ReentrantReadWriteLock() {"></a>public ReentrantReadWriteLock() {</h4><h4 id="this-false"><a href="#this-false" class="headerlink" title="this(false);"></a>this(false);</h4><h4 id="-26"><a href="#-26" class="headerlink" title="}"></a>}</h4><h4 id="x2F-使用给定的公平策略创建一个新的-ReentrantReadWriteLock-x2F"><a href="#x2F-使用给定的公平策略创建一个新的-ReentrantReadWriteLock-x2F" class="headerlink" title="&#x2F;** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock *&#x2F;"></a>&#x2F;** 使用给定的公平策略创建一个新的 ReentrantReadWriteLock *&#x2F;</h4><h4 id="public-ReentrantReadWriteLock-boolean-fair"><a href="#public-ReentrantReadWriteLock-boolean-fair" class="headerlink" title="public ReentrantReadWriteLock(boolean fair) {"></a>public ReentrantReadWriteLock(boolean fair) {</h4><h4 id="sync-x3D-fair-new-FairSync-new-NonfairSync"><a href="#sync-x3D-fair-new-FairSync-new-NonfairSync" class="headerlink" title="sync &#x3D; fair? new FairSync() : new NonfairSync();"></a>sync &#x3D; fair? new FairSync() : new NonfairSync();</h4><h4 id="readerLock-x3D-new-ReadLock-this"><a href="#readerLock-x3D-new-ReadLock-this" class="headerlink" title="readerLock &#x3D; new ReadLock(this);"></a>readerLock &#x3D; new ReadLock(this);</h4><h4 id="writerLock-x3D-new-WriteLock-this"><a href="#writerLock-x3D-new-WriteLock-this" class="headerlink" title="writerLock &#x3D; new WriteLock(this);"></a>writerLock &#x3D; new WriteLock(this);</h4><h4 id="-27"><a href="#-27" class="headerlink" title="}"></a>}</h4><h4 id="x2F-返回用于写入操作的锁-x2F"><a href="#x2F-返回用于写入操作的锁-x2F" class="headerlink" title="&#x2F;** 返回用于写入操作的锁 *&#x2F;"></a>&#x2F;** 返回用于写入操作的锁 *&#x2F;</h4><h4 id="public-ReentrantReadWriteLock-WriteLock-writeLock-return"><a href="#public-ReentrantReadWriteLock-WriteLock-writeLock-return" class="headerlink" title="public ReentrantReadWriteLock.WriteLock writeLock() { return"></a>public ReentrantReadWriteLock.WriteLock writeLock() { return</h4><h4 id="writerLock"><a href="#writerLock" class="headerlink" title="writerLock; }"></a>writerLock; }</h4><h4 id="x2F-返回用于读取操作的锁-x2F"><a href="#x2F-返回用于读取操作的锁-x2F" class="headerlink" title="&#x2F;** 返回用于读取操作的锁 *&#x2F;"></a>&#x2F;** 返回用于读取操作的锁 *&#x2F;</h4><h4 id="public-ReentrantReadWriteLock-ReadLock-readLock-return"><a href="#public-ReentrantReadWriteLock-ReadLock-readLock-return" class="headerlink" title="public ReentrantReadWriteLock.ReadLock readLock() { return"></a>public ReentrantReadWriteLock.ReadLock readLock() { return</h4><h4 id="readerLock"><a href="#readerLock" class="headerlink" title="readerLock; }"></a>readerLock; }</h4><h4 id="abstract-static-class-Sync-extends-AbstractQueuedSynchronizer"><a href="#abstract-static-class-Sync-extends-AbstractQueuedSynchronizer" class="headerlink" title="abstract static class Sync extends AbstractQueuedSynchronizer {}"></a>abstract static class Sync extends AbstractQueuedSynchronizer {}</h4><h4 id="static-final-class-NonfairSync-extends-Sync"><a href="#static-final-class-NonfairSync-extends-Sync" class="headerlink" title="static final class NonfairSync extends Sync {}"></a>static final class NonfairSync extends Sync {}</h4><h4 id="static-final-class-FairSync-extends-Sync"><a href="#static-final-class-FairSync-extends-Sync" class="headerlink" title="static final class FairSync extends Sync {}"></a>static final class FairSync extends Sync {}</h4><h4 id="public-static-class-ReadLock-implements-Lock-java-io-Serializable"><a href="#public-static-class-ReadLock-implements-Lock-java-io-Serializable" class="headerlink" title="public static class ReadLock implements Lock, java.io.Serializable {}"></a>public static class ReadLock implements Lock, java.io.Serializable {}</h4><h4 id="public-static-class-WriteLock-implements-Lock-java-io-Serializable"><a href="#public-static-class-WriteLock-implements-Lock-java-io-Serializable" class="headerlink" title="public static class WriteLock implements Lock, java.io.Serializable {}"></a>public static class WriteLock implements Lock, java.io.Serializable {}</h4><h4 id="-28"><a href="#-28" class="headerlink" title="}"></a>}</h4><h4 id="可以看到，ReentrantReadWriteLock实现了ReadWriteLock接口，"><a href="#可以看到，ReentrantReadWriteLock实现了ReadWriteLock接口，" class="headerlink" title="可以看到，ReentrantReadWriteLock实现了ReadWriteLock接口，"></a>可以看到，ReentrantReadWriteLock实现了ReadWriteLock接口，</h4><h4 id="ReadWriteLock接口定义了获取读锁和写锁的规范，具体需要实现类去实现；"><a href="#ReadWriteLock接口定义了获取读锁和写锁的规范，具体需要实现类去实现；" class="headerlink" title="ReadWriteLock接口定义了获取读锁和写锁的规范，具体需要实现类去实现；"></a>ReadWriteLock接口定义了获取读锁和写锁的规范，具体需要实现类去实现；</h4><h4 id="同时其还实现了Serializable接口，表示可以进行序列化，在源代码中可以看"><a href="#同时其还实现了Serializable接口，表示可以进行序列化，在源代码中可以看" class="headerlink" title="同时其还实现了Serializable接口，表示可以进行序列化，在源代码中可以看"></a>同时其还实现了Serializable接口，表示可以进行序列化，在源代码中可以看</h4><h4 id="到ReentrantReadWriteLock实现了自己的序列化逻辑。"><a href="#到ReentrantReadWriteLock实现了自己的序列化逻辑。" class="headerlink" title="到ReentrantReadWriteLock实现了自己的序列化逻辑。"></a>到ReentrantReadWriteLock实现了自己的序列化逻辑。</h4><h2 id="8-3-入门案例"><a href="#8-3-入门案例" class="headerlink" title="8 .3 入门案例"></a>8 .3 入门案例</h2><h4 id="场景-使用ReentrantReadWriteLock-对一个hashmap进行读和写操作"><a href="#场景-使用ReentrantReadWriteLock-对一个hashmap进行读和写操作" class="headerlink" title="场景: 使用ReentrantReadWriteLock 对一个hashmap进行读和写操作"></a>场景: 使用ReentrantReadWriteLock 对一个hashmap进行读和写操作</h4><h4 id="8-3-1-实现案例"><a href="#8-3-1-实现案例" class="headerlink" title="8 .3.1 实现案例"></a>8 .3.1 实现案例</h4><h5 id="x2F-x2F-资源类"><a href="#x2F-x2F-资源类" class="headerlink" title="&#x2F;&#x2F; 资源类"></a>&#x2F;&#x2F; 资源类</h5><p><strong>class</strong> MyCache {<br><em>&#x2F;&#x2F;</em> 创建 <em>map</em> 集合<br><strong>private volatile</strong> Map&lt;String,Object&gt; <strong>map</strong> &#x3D; <strong>new</strong> HashMap&lt;&gt;();</p>
<p><em>&#x2F;&#x2F;</em> 创建读写锁对象<br><strong>private</strong> ReadWriteLock <strong>rwLock</strong> &#x3D; <strong>new</strong> ReentrantReadWriteLock();</p>
<p><em>&#x2F;&#x2F;</em> 放数据<br><strong>public void</strong> put(String key,Object value) {<br><em>&#x2F;&#x2F;</em> 添加写锁<br><strong>rwLock</strong> .writeLock().lock();</p>
<p><strong>try</strong> {<br>System. <strong><em>out</em></strong> .println(Thread. <em>currentThread</em> ().getName()+ <strong>“<br>“</strong> +key);<br><em>&#x2F;&#x2F;</em> 暂停一会<br>TimeUnit. <strong><em>MICROSECONDS</em></strong> .sleep( 300 );<br><em>&#x2F;&#x2F;</em> 放数据<br><strong>map</strong> .put(key,value);<br>System. <strong><em>out</em></strong> .println(Thread. <em>currentThread</em> ().getName()+ <strong>“<br>“</strong> +key);<br>} <strong>catch</strong> (InterruptedException e) {<br>e.printStackTrace();<br>} <strong>finally</strong> {<br><em>&#x2F;&#x2F;</em> 释放写锁<br><strong>rwLock</strong> .writeLock().unlock();<br>}<br>}</p>
<p><em>&#x2F;&#x2F;</em> 取数据<br><strong>public</strong> Object get(String key) {<br><em>&#x2F;&#x2F;</em> 添加读锁<br><strong>rwLock</strong> .readLock().lock();<br>Object result &#x3D; <strong>null</strong> ;<br><strong>try</strong> {<br>System. <strong><em>out</em></strong> .println(Thread. <em>currentThread</em> ().getName()+ <strong>“<br>“</strong> +key);<br><em>&#x2F;&#x2F;</em> 暂停一会<br>TimeUnit. <strong><em>MICROSECONDS</em></strong> .sleep( 300 );<br>result &#x3D; <strong>map</strong> .get(key);<br>System. <strong><em>out</em></strong> .println(Thread. <em>currentThread</em> ().getName()+ <strong>“<br>“</strong> +key);<br>} <strong>catch</strong> (InterruptedException e) {</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">e.printStackTrace();</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">// 释放读锁</span><br><span class="line">rwLock .readLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-4-小结-重要"><a href="#8-4-小结-重要" class="headerlink" title="8. 4 小结(重要)"></a>8. 4 小结(重要)</h2><ul>
<li>在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发</li>
</ul>
<h4 id="现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有-。"><a href="#现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有-。" class="headerlink" title="现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。"></a>现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。</h4><ul>
<li>在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写</li>
</ul>
<h4 id="锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。"><a href="#锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。" class="headerlink" title="锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。"></a>锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。</h4><h4 id="原因-当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把"><a href="#原因-当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把" class="headerlink" title="原因: 当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把"></a>原因: 当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把</h4><h4 id="获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写"><a href="#获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写" class="headerlink" title="获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写"></a>获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写</h4><h4 id="锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释"><a href="#锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释" class="headerlink" title="锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释"></a>锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释</h4><h4 id="放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。"><a href="#放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。" class="headerlink" title="放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。"></a>放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。</h4><h1 id="9-阻塞队列"><a href="#9-阻塞队列" class="headerlink" title="9 阻塞队列"></a>9 阻塞队列</h1><h2 id="9-1-BlockingQueue简介"><a href="#9-1-BlockingQueue简介" class="headerlink" title="9 .1 BlockingQueue简介"></a>9 .1 BlockingQueue简介</h2><h4 id="Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全"><a href="#Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全" class="headerlink" title="Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全"></a>Concurrent包中，BlockingQueue很好的解决了多线程中，如何高效安全</h4><h4 id="“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建"><a href="#“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建" class="headerlink" title="“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建"></a>“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建</h4><h4 id="高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭"><a href="#高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭" class="headerlink" title="高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭"></a>高质量的多线程程序带来极大的便利。本文详细介绍了BlockingQueue家庭</h4><h4 id="中的所有成员，包括他们各自的功能以及常见使用场景。"><a href="#中的所有成员，包括他们各自的功能以及常见使用场景。" class="headerlink" title="中的所有成员，包括他们各自的功能以及常见使用场景。"></a>中的所有成员，包括他们各自的功能以及常见使用场景。</h4><h4 id="阻塞队列，顾名思义，首先它是一个队列-通过一个共享的队列，可以使得数据"><a href="#阻塞队列，顾名思义，首先它是一个队列-通过一个共享的队列，可以使得数据" class="headerlink" title="阻塞队列，顾名思义，首先它是一个队列, 通过一个共享的队列，可以使得数据"></a>阻塞队列，顾名思义，首先它是一个队列, 通过一个共享的队列，可以使得数据</h4><h4 id="由队列的一端输入，从另外一端输出；"><a href="#由队列的一端输入，从另外一端输出；" class="headerlink" title="由队列的一端输入，从另外一端输出；"></a>由队列的一端输入，从另外一端输出；</h4><h5 id="当队列是空的，从队列中获取元素的操作将会被阻塞"><a href="#当队列是空的，从队列中获取元素的操作将会被阻塞" class="headerlink" title="当队列是空的，从队列中获取元素的操作将会被阻塞"></a>当队列是空的，从队列中获取元素的操作将会被阻塞</h5><h5 id="当队列是满的，从队列中添加元素的操作将会被阻塞"><a href="#当队列是满的，从队列中添加元素的操作将会被阻塞" class="headerlink" title="当队列是满的，从队列中添加元素的操作将会被阻塞"></a>当队列是满的，从队列中添加元素的操作将会被阻塞</h5><h5 id="试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素"><a href="#试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素" class="headerlink" title="试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素"></a>试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素</h5><h5 id="试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多"><a href="#试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多" class="headerlink" title="试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多"></a>试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多</h5><h5 id="个元素或者完全清空，使队列变得空闲起来并后续新增"><a href="#个元素或者完全清空，使队列变得空闲起来并后续新增" class="headerlink" title="个元素或者完全清空，使队列变得空闲起来并后续新增"></a>个元素或者完全清空，使队列变得空闲起来并后续新增</h5><h4 id="常用的队列主要有以下两种："><a href="#常用的队列主要有以下两种：" class="headerlink" title="常用的队列主要有以下两种："></a>常用的队列主要有以下两种：</h4><ul>
<li>先进先出（FIFO）：先插入的队列的元素也最先出队列，类似于排队的功能。</li>
</ul>
<h4 id="从某种程度上来说这种队列也体现了一种公平性"><a href="#从某种程度上来说这种队列也体现了一种公平性" class="headerlink" title="从某种程度上来说这种队列也体现了一种公平性"></a>从某种程度上来说这种队列也体现了一种公平性</h4><ul>
<li>后进先出（LIFO）：后插入队列的元素最先出队列，这种队列优先处理最近发</li>
</ul>
<h4 id="生的事件-栈"><a href="#生的事件-栈" class="headerlink" title="生的事件(栈)"></a>生的事件(栈)</h4><h5 id="在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起"><a href="#在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起" class="headerlink" title="在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起"></a>在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起</h5><h5 id="的线程又会自动被唤起"><a href="#的线程又会自动被唤起" class="headerlink" title="的线程又会自动被唤起"></a>的线程又会自动被唤起</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么需要BlockingQueue</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切</span><br><span class="line">BlockingQueue都给你一手包办了</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在concurrent包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细</span><br><span class="line">节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。</span><br></pre></td></tr></table></figure>

<h4 id="多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和"><a href="#多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和" class="headerlink" title="多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和"></a>多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和</h4><h4 id="“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我"><a href="#“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我" class="headerlink" title="“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我"></a>“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我</h4><h4 id="们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准"><a href="#们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准" class="headerlink" title="们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准"></a>们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准</h4><h4 id="备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地"><a href="#备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地" class="headerlink" title="备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地"></a>备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地</h4><h4 id="解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一"><a href="#解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一" class="headerlink" title="解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一"></a>解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一</h4><h4 id="发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度"><a href="#发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度" class="headerlink" title="发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度"></a>发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度</h4><h4 id="大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么"><a href="#大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么" class="headerlink" title="大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么"></a>大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么</h4><h4 id="生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的"><a href="#生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的" class="headerlink" title="生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的"></a>生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的</h4><h4 id="数据处理完毕，反之亦然。"><a href="#数据处理完毕，反之亦然。" class="headerlink" title="数据处理完毕，反之亦然。"></a>数据处理完毕，反之亦然。</h4><ul>
<li>当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），</li>
</ul>
<h4 id="直到有数据放入队列"><a href="#直到有数据放入队列" class="headerlink" title="直到有数据放入队列"></a>直到有数据放入队列</h4><ul>
<li>当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），</li>
</ul>
<h4 id="直到队列中有空的位置，线程被自动唤醒"><a href="#直到队列中有空的位置，线程被自动唤醒" class="headerlink" title="直到队列中有空的位置，线程被自动唤醒"></a>直到队列中有空的位置，线程被自动唤醒</h4><h2 id="9-2-BlockingQueue核心方法"><a href="#9-2-BlockingQueue核心方法" class="headerlink" title="9 .2 BlockingQueue核心方法"></a>9 .2 BlockingQueue核心方法</h2><h4 id="BlockingQueue的核心方法-："><a href="#BlockingQueue的核心方法-：" class="headerlink" title="BlockingQueue的核心方法 ："></a>BlockingQueue的核心方法 ：</h4><h4 id="1-放入数据"><a href="#1-放入数据" class="headerlink" title="1.放入数据"></a>1.放入数据</h4><ul>
<li>offer(anObject):表示如果可能的话,将anObject加到BlockingQueue里,即</li>
</ul>
<h4 id="如果BlockingQueue可以容纳-则返回true-否则返回false-（本方法不阻塞当"><a href="#如果BlockingQueue可以容纳-则返回true-否则返回false-（本方法不阻塞当" class="headerlink" title="如果BlockingQueue可以容纳,则返回true,否则返回false. （本方法不阻塞当"></a>如果BlockingQueue可以容纳,则返回true,否则返回false. （本方法不阻塞当</h4><h4 id="前执行方法的线程）"><a href="#前执行方法的线程）" class="headerlink" title="前执行方法的线程）"></a>前执行方法的线程）</h4><ul>
<li>offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定</li>
</ul>
<h4 id="的时间内，还不能往队列中加入BlockingQueue，则返回失败"><a href="#的时间内，还不能往队列中加入BlockingQueue，则返回失败" class="headerlink" title="的时间内，还不能往队列中加入BlockingQueue，则返回失败"></a>的时间内，还不能往队列中加入BlockingQueue，则返回失败</h4><ul>
<li>put(anObject):把anObject加到BlockingQueue里,如果BlockQueue没有</li>
</ul>
<h4 id="空间-则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续"><a href="#空间-则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续" class="headerlink" title="空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续."></a>空间,则调用此方法的线程被阻断直到BlockingQueue里面有空间再继续.</h4><h4 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2.获取数据"></a>2.获取数据</h4><ul>
<li>poll(time): 取走BlockingQueue里排在首位的对象,若不能立即取出, <strong>则可以等</strong></li>
</ul>
<h4 id="time参数规定的时间-取不到时返回null"><a href="#time参数规定的时间-取不到时返回null" class="headerlink" title="time参数规定的时间,取不到时返回null"></a>time参数规定的时间,取不到时返回null</h4><ul>
<li>poll(long timeout, TimeUnit unit)：从BlockingQueue取出一个队首的对象，</li>
</ul>
<h4 id="如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知"><a href="#如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知" class="headerlink" title="如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知"></a>如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知</h4><h4 id="道时间超时还没有数据可取，返回失败。"><a href="#道时间超时还没有数据可取，返回失败。" class="headerlink" title="道时间超时还没有数据可取，返回失败。"></a>道时间超时还没有数据可取，返回失败。</h4><ul>
<li>take(): 取走BlockingQueue里排在首位的对象,若BlockingQueue为空, <strong>阻断</strong></li>
</ul>
<h4 id="进入等待状态直到BlockingQueue有新的数据被加入"><a href="#进入等待状态直到BlockingQueue有新的数据被加入" class="headerlink" title="进入等待状态直到BlockingQueue有新的数据被加入 ;"></a>进入等待状态直到BlockingQueue有新的数据被加入 ;</h4><ul>
<li>drainTo(): 一次性从BlockingQueue获取所有可用的数据对象（还可以指定</li>
</ul>
<h4 id="获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加"><a href="#获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加" class="headerlink" title="获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加"></a>获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加</h4><h4 id="锁或释放锁。"><a href="#锁或释放锁。" class="headerlink" title="锁或释放锁。"></a>锁或释放锁。</h4><h2 id="9-3-入门案例"><a href="#9-3-入门案例" class="headerlink" title="9 .3 入门案例"></a>9 .3 入门案例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line">import java.util.concurrent.BlockingQueue;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 阻塞队列</span><br><span class="line">*/</span><br><span class="line">public class BlockingQueueDemo &#123;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws InterruptedException &#123;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F; List list &#x3D; new ArrayList();</p>
<p>BlockingQueue<String> blockingQueue &#x3D; new ArrayBlockingQueue&lt;&gt;( 3 );<br>&#x2F;&#x2F;第一组<br>&#x2F;&#x2F; System.out.println(blockingQueue.add(“a”));<br>&#x2F;&#x2F; System.out.println(blockingQueue.add(“b”));<br>&#x2F;&#x2F; System.out.println(blockingQueue.add(“c”));<br>&#x2F;&#x2F; System.out.println(blockingQueue.element());</p>
<p>&#x2F;&#x2F;System.out.println(blockingQueue.add(“x”));<br>&#x2F;&#x2F; System.out.println(blockingQueue.remove());<br>&#x2F;&#x2F; System.out.println(blockingQueue.remove());<br>&#x2F;&#x2F; System.out.println(blockingQueue.remove());<br>&#x2F;&#x2F; System.out.println(blockingQueue.remove());<br>&#x2F;&#x2F; 第二组<br>&#x2F;&#x2F; System.out.println(blockingQueue.offer(“a”));<br>&#x2F;&#x2F; System.out.println(blockingQueue.offer(“b”));<br>&#x2F;&#x2F; System.out.println(blockingQueue.offer(“c”));<br>&#x2F;&#x2F; System.out.println(blockingQueue.offer(“x”));<br>&#x2F;&#x2F; System.out.println(blockingQueue.poll());<br>&#x2F;&#x2F; System.out.println(blockingQueue.poll());<br>&#x2F;&#x2F; System.out.println(blockingQueue.poll());<br>&#x2F;&#x2F; System.out.println(blockingQueue.poll());<br>&#x2F;&#x2F; 第三组<br>&#x2F;&#x2F; blockingQueue.put(“a”);<br>&#x2F;&#x2F; blockingQueue.put(“b”);<br>&#x2F;&#x2F; blockingQueue.put(“c”);<br>&#x2F;&#x2F; &#x2F;&#x2F;blockingQueue.put(“x”);<br>&#x2F;&#x2F; System.out.println(blockingQueue.take());<br>&#x2F;&#x2F; System.out.println(blockingQueue.take());<br>&#x2F;&#x2F; System.out.println(blockingQueue.take());<br>&#x2F;&#x2F; System.out.println(blockingQueue.take());</p>
<p>&#x2F;&#x2F; 第四组<br>System.out.println(blockingQueue.offer(“a”));<br>System.out.println(blockingQueue.offer(“b”));<br>System.out.println(blockingQueue.offer(“c”));<br>System.out.println(blockingQueue.offer(“a”,3L, TimeUnit.SECONDS));</p>
<h5 id="-29"><a href="#-29" class="headerlink" title="}"></a>}</h5><h5 id="-30"><a href="#-30" class="headerlink" title="}"></a>}</h5><h2 id="9-4-常见的BlockingQueue"><a href="#9-4-常见的BlockingQueue" class="headerlink" title="9 .4 常见的BlockingQueue"></a>9 .4 常见的BlockingQueue</h2><h3 id="9-4-1-ArrayBlockingQueue-常用"><a href="#9-4-1-ArrayBlockingQueue-常用" class="headerlink" title="9 .4.1 ArrayBlockingQueue(常用)"></a>9 .4.1 ArrayBlockingQueue(常用)</h3><h4 id="基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数"><a href="#基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数" class="headerlink" title="基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数"></a>基于数组的阻塞队列实现，在ArrayBlockingQueue内部，维护了一个定长数</h4><h4 id="组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数"><a href="#组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数" class="headerlink" title="组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数"></a>组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数</h4><h4 id="组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的"><a href="#组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的" class="headerlink" title="组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的"></a>组外，ArrayBlockingQueue内部还保存着两个整形变量，分别标识着队列的</h4><h4 id="头部和尾部在数组中的位置。"><a href="#头部和尾部在数组中的位置。" class="headerlink" title="头部和尾部在数组中的位置。"></a>头部和尾部在数组中的位置。</h4><h4 id="ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个"><a href="#ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个" class="headerlink" title="ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个"></a>ArrayBlockingQueue在生产者放入数据和消费者获取数据，都是共用同一个</h4><h4 id="锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于"><a href="#锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于" class="headerlink" title="锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于"></a>锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于</h4><h4 id="LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可"><a href="#LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可" class="headerlink" title="LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可"></a>LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue完全可</h4><h4 id="以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug-Lea之"><a href="#以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug-Lea之" class="headerlink" title="以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之"></a>以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea之</h4><h4 id="所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已"><a href="#所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已" class="headerlink" title="所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已"></a>所以没这样去做，也许是因为ArrayBlockingQueue的数据写入和获取操作已</h4><h4 id="经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其"><a href="#经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其" class="headerlink" title="经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其"></a>经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其</h4><h4 id="在性能上完全占不到任何便宜。-ArrayBlockingQueue和"><a href="#在性能上完全占不到任何便宜。-ArrayBlockingQueue和" class="headerlink" title="在性能上完全占不到任何便宜。 ArrayBlockingQueue和"></a>在性能上完全占不到任何便宜。 ArrayBlockingQueue和</h4><h4 id="LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除"><a href="#LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除" class="headerlink" title="LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除"></a>LinkedBlockingQueue间还有一个明显的不同之处在于，前者在插入或删除</h4><h4 id="元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的"><a href="#元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的" class="headerlink" title="元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的"></a>元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的</h4><h4 id="Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于"><a href="#Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于" class="headerlink" title="Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于"></a>Node对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于</h4><h4 id="GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还"><a href="#GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还" class="headerlink" title="GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还"></a>GC的影响还是存在一定的区别。而在创建ArrayBlockingQueue时，我们还</h4><h4 id="可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。"><a href="#可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。" class="headerlink" title="可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。"></a>可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。</h4><h4 id="x3D-x3D-一句话总结-由数组结构组成的有界阻塞队列。-x3D-x3D"><a href="#x3D-x3D-一句话总结-由数组结构组成的有界阻塞队列。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D; 一句话总结: 由数组结构组成的有界阻塞队列。 &#x3D;&#x3D;"></a>&#x3D;&#x3D; 一句话总结: 由数组结构组成的有界阻塞队列。 &#x3D;&#x3D;</h4><h4 id="9-4-2-LinkedBlockingQueue-常用"><a href="#9-4-2-LinkedBlockingQueue-常用" class="headerlink" title="9 .4.2 LinkedBlockingQueue(常用)"></a>9 .4.2 LinkedBlockingQueue(常用)</h4><h4 id="基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一"><a href="#基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一" class="headerlink" title="基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一"></a>基于链表的阻塞队列，同ArrayListBlockingQueue类似，其内部也维持着一</h4><h4 id="个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据"><a href="#个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据" class="headerlink" title="个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据"></a>个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据</h4><h4 id="时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；"><a href="#时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；" class="headerlink" title="时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；"></a>时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；</h4><h4 id="只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过"><a href="#只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过" class="headerlink" title="只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过"></a>只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue可以通过</h4><h4 id="构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份"><a href="#构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份" class="headerlink" title="构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份"></a>构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份</h4><h4 id="数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。"><a href="#数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。" class="headerlink" title="数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。"></a>数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。</h4><h4 id="而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生"><a href="#而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生" class="headerlink" title="而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生"></a>而LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生</h4><h4 id="产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发"><a href="#产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发" class="headerlink" title="产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发"></a>产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发</h4><h4 id="的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列"><a href="#的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列" class="headerlink" title="的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列"></a>的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列</h4><h4 id="的并发性能。"><a href="#的并发性能。" class="headerlink" title="的并发性能。"></a>的并发性能。</h4><h4 id="ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用"><a href="#ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用" class="headerlink" title="ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用"></a>ArrayBlockingQueue和LinkedBlockingQueue是两个最普通也是最常用</h4><h4 id="的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个"><a href="#的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个" class="headerlink" title="的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个"></a>的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个</h4><h4 id="类足以。"><a href="#类足以。" class="headerlink" title="类足以。"></a>类足以。</h4><h4 id="x3D-x3D-一句话总结-由链表结构组成的有界（但大小默认值为"><a href="#x3D-x3D-一句话总结-由链表结构组成的有界（但大小默认值为" class="headerlink" title="&#x3D;&#x3D; 一句话总结: 由链表结构组成的有界（但大小默认值为"></a>&#x3D;&#x3D; 一句话总结: 由链表结构组成的有界（但大小默认值为</h4><h4 id="integer-MAX-VALUE）阻塞队列。-x3D-x3D"><a href="#integer-MAX-VALUE）阻塞队列。-x3D-x3D" class="headerlink" title="integer.MAX_VALUE）阻塞队列。 &#x3D;&#x3D;"></a>integer.MAX_VALUE）阻塞队列。 &#x3D;&#x3D;</h4><h4 id="9-4-3-DelayQueue"><a href="#9-4-3-DelayQueue" class="headerlink" title="9 .4.3 DelayQueue"></a>9 .4.3 DelayQueue</h4><h4 id="DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到"><a href="#DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到" class="headerlink" title="DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到"></a>DelayQueue中的元素只有当其指定的延迟时间到了，才能够从队列中获取到</h4><h4 id="该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的"><a href="#该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的" class="headerlink" title="该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的"></a>该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据的</h4><h4 id="操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻"><a href="#操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻" class="headerlink" title="操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻"></a>操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻</h4><h4 id="塞。"><a href="#塞。" class="headerlink" title="塞。"></a>塞。</h4><h4 id="x3D-x3D-一句话总结-使用优先级队列实现的延迟无界阻塞队列。-x3D-x3D"><a href="#x3D-x3D-一句话总结-使用优先级队列实现的延迟无界阻塞队列。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D; 一句话总结: 使用优先级队列实现的延迟无界阻塞队列。 &#x3D;&#x3D;"></a>&#x3D;&#x3D; 一句话总结: 使用优先级队列实现的延迟无界阻塞队列。 &#x3D;&#x3D;</h4><h4 id="9-4-4-PriorityBlockingQueue"><a href="#9-4-4-PriorityBlockingQueue" class="headerlink" title="9 .4.4 PriorityBlockingQueue"></a>9 .4.4 PriorityBlockingQueue</h4><h4 id="基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来"><a href="#基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来" class="headerlink" title="基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来"></a>基于优先级的阻塞队列（优先级的判断通过构造函数传入的Compator对象来</h4><h4 id="决定），但需要注意的是PriorityBlockingQueue并-不会阻塞数据生产者，而"><a href="#决定），但需要注意的是PriorityBlockingQueue并-不会阻塞数据生产者，而" class="headerlink" title="决定），但需要注意的是PriorityBlockingQueue并 不会阻塞数据生产者，而"></a>决定），但需要注意的是PriorityBlockingQueue并 不会阻塞数据生产者，而</h4><h4 id="只会在没有可消费的数据时，阻塞数据的消费者-。"><a href="#只会在没有可消费的数据时，阻塞数据的消费者-。" class="headerlink" title="只会在没有可消费的数据时，阻塞数据的消费者 。"></a>只会在没有可消费的数据时，阻塞数据的消费者 。</h4><h4 id="因此使用的时候要特别注意，-生产者生产数据的速度绝对不能快于消费者消费"><a href="#因此使用的时候要特别注意，-生产者生产数据的速度绝对不能快于消费者消费" class="headerlink" title="因此使用的时候要特别注意， 生产者生产数据的速度绝对不能快于消费者消费"></a>因此使用的时候要特别注意， 生产者生产数据的速度绝对不能快于消费者消费</h4><h4 id="数据的速度-，否则时间一长，会最终耗尽所有的可用堆内存空间。"><a href="#数据的速度-，否则时间一长，会最终耗尽所有的可用堆内存空间。" class="headerlink" title="数据的速度 ，否则时间一长，会最终耗尽所有的可用堆内存空间。"></a>数据的速度 ，否则时间一长，会最终耗尽所有的可用堆内存空间。</h4><h4 id="在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是-公平锁-。"><a href="#在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是-公平锁-。" class="headerlink" title="在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是 公平锁 。"></a>在实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是 公平锁 。</h4><h4 id="x3D-x3D-一句话总结-支持优先级排序的无界阻塞队列。-x3D-x3D"><a href="#x3D-x3D-一句话总结-支持优先级排序的无界阻塞队列。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D; 一句话总结: 支持优先级排序的无界阻塞队列。 &#x3D;&#x3D;"></a>&#x3D;&#x3D; 一句话总结: 支持优先级排序的无界阻塞队列。 &#x3D;&#x3D;</h4><h4 id="9-4-5-SynchronousQueue"><a href="#9-4-5-SynchronousQueue" class="headerlink" title="9 .4.5 SynchronousQueue"></a>9 .4.5 SynchronousQueue</h4><h4 id="一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产"><a href="#一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产" class="headerlink" title="一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产"></a>一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产</h4><h4 id="者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须"><a href="#者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须" class="headerlink" title="者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须"></a>者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须</h4><h4 id="亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么"><a href="#亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么" class="headerlink" title="亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么"></a>亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么</h4><h4 id="对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一"><a href="#对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一" class="headerlink" title="对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一"></a>对不起，大家都在集市等待。相对于有缓冲的BlockingQueue来说，少了一</h4><h4 id="个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经"><a href="#个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经" class="headerlink" title="个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经"></a>个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经</h4><h4 id="销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以"><a href="#销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以" class="headerlink" title="销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以"></a>销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以</h4><h4 id="库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式"><a href="#库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式" class="headerlink" title="库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式"></a>库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式</h4><h4 id="会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得"><a href="#会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得" class="headerlink" title="会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得"></a>会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得</h4><h4 id="产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能"><a href="#产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能" class="headerlink" title="产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能"></a>产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能</h4><h4 id="可能会降低。"><a href="#可能会降低。" class="headerlink" title="可能会降低。"></a>可能会降低。</h4><h4 id="声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的"><a href="#声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的" class="headerlink" title="声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的"></a>声明一个SynchronousQueue有两种不同的方式，它们之间有着不太一样的</h4><h4 id="行为。"><a href="#行为。" class="headerlink" title="行为。"></a>行为。</h4><h4 id="公平模式和非公平模式的区别"><a href="#公平模式和非公平模式的区别" class="headerlink" title="公平模式和非公平模式的区别:"></a>公平模式和非公平模式的区别:</h4><ul>
<li>公平模式：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞</li>
</ul>
<h4 id="多余的生产者和消费者，从而体系整体的公平策略；"><a href="#多余的生产者和消费者，从而体系整体的公平策略；" class="headerlink" title="多余的生产者和消费者，从而体系整体的公平策略；"></a>多余的生产者和消费者，从而体系整体的公平策略；</h4><ul>
<li>非公平模式（SynchronousQueue默认）：SynchronousQueue采用非公平</li>
</ul>
<h4 id="锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，"><a href="#锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，" class="headerlink" title="锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，"></a>锁，同时配合一个LIFO队列来管理多余的生产者和消费者，而后一种模式，</h4><h4 id="如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有"><a href="#如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有" class="headerlink" title="如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有"></a>如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有</h4><h4 id="某些生产者或者是消费者的数据永远都得不到处理。"><a href="#某些生产者或者是消费者的数据永远都得不到处理。" class="headerlink" title="某些生产者或者是消费者的数据永远都得不到处理。"></a>某些生产者或者是消费者的数据永远都得不到处理。</h4><h4 id="x3D-x3D-一句话总结-不存储元素的阻塞队列，也即单个元素的队列。-x3D-x3D"><a href="#x3D-x3D-一句话总结-不存储元素的阻塞队列，也即单个元素的队列。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D; 一句话总结: 不存储元素的阻塞队列，也即单个元素的队列。 &#x3D;&#x3D;"></a>&#x3D;&#x3D; 一句话总结: 不存储元素的阻塞队列，也即单个元素的队列。 &#x3D;&#x3D;</h4><h4 id="9-4-6-LinkedTransferQueue"><a href="#9-4-6-LinkedTransferQueue" class="headerlink" title="9 .4.6 LinkedTransferQueue"></a>9 .4.6 LinkedTransferQueue</h4><h4 id="LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队"><a href="#LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队" class="headerlink" title="LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队"></a>LinkedTransferQueue是一个由链表结构组成的无界阻塞TransferQueue队</h4><h4 id="列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和"><a href="#列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和" class="headerlink" title="列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和"></a>列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和</h4><h4 id="transfer方法。"><a href="#transfer方法。" class="headerlink" title="transfer方法。"></a>transfer方法。</h4><h4 id="LinkedTransferQueue采用一种预占模式。意思就是消费者线程取元素时，如"><a href="#LinkedTransferQueue采用一种预占模式。意思就是消费者线程取元素时，如" class="headerlink" title="LinkedTransferQueue采用一种预占模式。意思就是消费者线程取元素时，如"></a>LinkedTransferQueue采用一种预占模式。意思就是消费者线程取元素时，如</h4><h4 id="果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素"><a href="#果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素" class="headerlink" title="果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素"></a>果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素</h4><h4 id="为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时"><a href="#为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时" class="headerlink" title="为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时"></a>为null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时</h4><h4 id="发现有一个元素为null的节点，生产者线程就不入队了，直接就将元素填充到"><a href="#发现有一个元素为null的节点，生产者线程就不入队了，直接就将元素填充到" class="headerlink" title="发现有一个元素为null的节点，生产者线程就不入队了，直接就将元素填充到"></a>发现有一个元素为null的节点，生产者线程就不入队了，直接就将元素填充到</h4><h4 id="该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的"><a href="#该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的" class="headerlink" title="该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的"></a>该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的</h4><h4 id="方法返回。"><a href="#方法返回。" class="headerlink" title="方法返回。"></a>方法返回。</h4><h4 id="x3D-x3D-一句话总结-由链表组成的无界阻塞队列。-x3D-x3D"><a href="#x3D-x3D-一句话总结-由链表组成的无界阻塞队列。-x3D-x3D" class="headerlink" title="&#x3D;&#x3D; 一句话总结: 由链表组成的无界阻塞队列。 &#x3D;&#x3D;"></a>&#x3D;&#x3D; 一句话总结: 由链表组成的无界阻塞队列。 &#x3D;&#x3D;</h4><h4 id="9-4-7-LinkedBlockingDeque"><a href="#9-4-7-LinkedBlockingDeque" class="headerlink" title="9 .4.7 LinkedBlockingDeque"></a>9 .4.7 LinkedBlockingDeque</h4><h4 id="LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列，即可以从队"><a href="#LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列，即可以从队" class="headerlink" title="LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列，即可以从队"></a>LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列，即可以从队</h4><h4 id="列的两端插入和移除元素。"><a href="#列的两端插入和移除元素。" class="headerlink" title="列的两端插入和移除元素。"></a>列的两端插入和移除元素。</h4><h4 id="对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作"><a href="#对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作" class="headerlink" title="对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作"></a>对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作</h4><h4 id="可能会阻塞住该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情"><a href="#可能会阻塞住该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情" class="headerlink" title="可能会阻塞住该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情"></a>可能会阻塞住该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情</h4><h4 id="况"><a href="#况" class="headerlink" title="况"></a>况</h4><ul>
<li>插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时</li>
</ul>
<h4 id="再讲该元素插入，该操作可以通过设置超时参数，超时后返回-false-表示操作"><a href="#再讲该元素插入，该操作可以通过设置超时参数，超时后返回-false-表示操作" class="headerlink" title="再讲该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作"></a>再讲该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作</h4><h4 id="失败，也可以不设置超时参数一直阻塞，中断后抛出InterruptedException异"><a href="#失败，也可以不设置超时参数一直阻塞，中断后抛出InterruptedException异" class="headerlink" title="失败，也可以不设置超时参数一直阻塞，中断后抛出InterruptedException异"></a>失败，也可以不设置超时参数一直阻塞，中断后抛出InterruptedException异</h4><h4 id="常"><a href="#常" class="headerlink" title="常"></a>常</h4><ul>
<li>读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可</li>
</ul>
<h4 id="以通过设置超时参数"><a href="#以通过设置超时参数" class="headerlink" title="以通过设置超时参数"></a>以通过设置超时参数</h4><h4 id="x3D-x3D-一句话总结-由链表组成的双向阻塞队列-x3D-x3D"><a href="#x3D-x3D-一句话总结-由链表组成的双向阻塞队列-x3D-x3D" class="headerlink" title="&#x3D;&#x3D; 一句话总结: 由链表组成的双向阻塞队列 &#x3D;&#x3D;"></a>&#x3D;&#x3D; 一句话总结: 由链表组成的双向阻塞队列 &#x3D;&#x3D;</h4><h4 id="9-5-小结"><a href="#9-5-小结" class="headerlink" title="9 .5 小结"></a>9 .5 小结</h4><h4 id="1-在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件"><a href="#1-在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件" class="headerlink" title="1. 在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件"></a>1. 在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件</h4><h4 id="满足，被挂起的线程又会自动被唤起"><a href="#满足，被挂起的线程又会自动被唤起" class="headerlink" title="满足，被挂起的线程又会自动被唤起"></a>满足，被挂起的线程又会自动被唤起</h4><h4 id="2-为什么需要BlockingQueue-在concurrent包发布以前，在多线程环境下，"><a href="#2-为什么需要BlockingQueue-在concurrent包发布以前，在多线程环境下，" class="headerlink" title="2. 为什么需要BlockingQueue? 在concurrent包发布以前，在多线程环境下，"></a>2. 为什么需要BlockingQueue? 在concurrent包发布以前，在多线程环境下，</h4><h4 id="我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，"><a href="#我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，" class="headerlink" title="我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，"></a>我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，</h4><h4 id="而这会给我们的程序带来不小的复杂度。使用后我们不需要关心什么时候需要"><a href="#而这会给我们的程序带来不小的复杂度。使用后我们不需要关心什么时候需要" class="headerlink" title="而这会给我们的程序带来不小的复杂度。使用后我们不需要关心什么时候需要"></a>而这会给我们的程序带来不小的复杂度。使用后我们不需要关心什么时候需要</h4><h4 id="阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手"><a href="#阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手" class="headerlink" title="阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手"></a>阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手</h4><h4 id="包办了"><a href="#包办了" class="headerlink" title="包办了"></a>包办了</h4><h1 id="10-ThreadPool-线程池"><a href="#10-ThreadPool-线程池" class="headerlink" title="10 ThreadPool 线程池"></a>10 ThreadPool 线程池</h1><h4 id="10-1-线程池简介"><a href="#10-1-线程池简介" class="headerlink" title="10 .1 线程池简介"></a>10 .1 线程池简介</h4><h4 id="线程池（英语：thread-pool）：一种线程使用模式。线程过多会带来调度开销，"><a href="#线程池（英语：thread-pool）：一种线程使用模式。线程过多会带来调度开销，" class="headerlink" title="线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，"></a>线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，</h4><h4 id="进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理"><a href="#进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理" class="headerlink" title="进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理"></a>进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理</h4><h4 id="者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代"><a href="#者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代" class="headerlink" title="者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代"></a>者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代</h4><h4 id="价。线程池不仅能够保证内核的充分利用，还能防止过分调度。"><a href="#价。线程池不仅能够保证内核的充分利用，还能防止过分调度。" class="headerlink" title="价。线程池不仅能够保证内核的充分利用，还能防止过分调度。"></a>价。线程池不仅能够保证内核的充分利用，还能防止过分调度。</h4><h4 id="例子：-10-年前单核CPU电脑，假的多线程，像马戏团小丑玩多个球，CPU需"><a href="#例子：-10-年前单核CPU电脑，假的多线程，像马戏团小丑玩多个球，CPU需" class="headerlink" title="例子： 10 年前单核CPU电脑，假的多线程，像马戏团小丑玩多个球，CPU需"></a>例子： 10 年前单核CPU电脑，假的多线程，像马戏团小丑玩多个球，CPU需</h4><h4 id="要来回切换。-现在是多核电脑，多个线程各自跑在独立的CPU上，不用切换"><a href="#要来回切换。-现在是多核电脑，多个线程各自跑在独立的CPU上，不用切换" class="headerlink" title="要来回切换。 现在是多核电脑，多个线程各自跑在独立的CPU上，不用切换"></a>要来回切换。 现在是多核电脑，多个线程各自跑在独立的CPU上，不用切换</h4><h4 id="效率高。"><a href="#效率高。" class="headerlink" title="效率高。"></a>效率高。</h4><h4 id="线程池的优势：-线程池做的工作只要是控制运行的线程数量，处理过程中将任"><a href="#线程池的优势：-线程池做的工作只要是控制运行的线程数量，处理过程中将任" class="headerlink" title="线程池的优势： 线程池做的工作只要是控制运行的线程数量，处理过程中将任"></a>线程池的优势： 线程池做的工作只要是控制运行的线程数量，处理过程中将任</h4><h4 id="务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，"><a href="#务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，" class="headerlink" title="务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，"></a>务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，</h4><h4 id="超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。"><a href="#超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。" class="headerlink" title="超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。"></a>超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。</h4><h4 id="它的主要特点为："><a href="#它的主要特点为：" class="headerlink" title="它的主要特点为："></a>它的主要特点为：</h4><ul>
<li>降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。</li>
<li>提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。</li>
<li>提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资</li>
</ul>
<h4 id="源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。"><a href="#源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。" class="headerlink" title="源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。"></a>源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</h4><ul>
<li><strong>Java中的线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，</strong><br>  <strong>ExecutorService，ThreadPoolExecutor这几个类</strong></li>
</ul>
<h4 id="10-2-线程池参数说明"><a href="#10-2-线程池参数说明" class="headerlink" title="10 .2 线程池参数说明"></a>10 .2 线程池参数说明</h4><h4 id="本次介绍-5-种类型的线程池"><a href="#本次介绍-5-种类型的线程池" class="headerlink" title="本次介绍 5 种类型的线程池"></a>本次介绍 5 种类型的线程池</h4><h4 id="10-2-1常用参数-重点"><a href="#10-2-1常用参数-重点" class="headerlink" title="10 .2.1常用参数(重点)"></a>10 .2.1常用参数(重点)</h4><ul>
<li>corePoolSize线程池的核心线程数</li>
<li>maximumPoolSize能容纳的最大线程数</li>
<li>keepAliveTime空闲线程存活时间</li>
<li>unit 存活的时间单位</li>
<li>workQueue 存放提交但未执行任务的队列</li>
<li>threadFactory 创建线程的工厂类</li>
<li>handler 等待队列满后的拒绝策略</li>
</ul>
<h4 id="线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize-核心线"><a href="#线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize-核心线" class="headerlink" title="线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize - 核心线"></a>线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize - 核心线</h4><h4 id="程数，也即最小的线程数。workQueue-阻塞队列-。-maximumPoolSize"><a href="#程数，也即最小的线程数。workQueue-阻塞队列-。-maximumPoolSize" class="headerlink" title="程数，也即最小的线程数。workQueue - 阻塞队列 。 maximumPoolSize -"></a>程数，也即最小的线程数。workQueue - 阻塞队列 。 maximumPoolSize -</h4><h4 id="最大线程数"><a href="#最大线程数" class="headerlink" title="最大线程数"></a>最大线程数</h4><h4 id="当提交任务数大于-corePoolSize-的时候，会优先将任务放到-workQueue-阻"><a href="#当提交任务数大于-corePoolSize-的时候，会优先将任务放到-workQueue-阻" class="headerlink" title="当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻"></a>当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻</h4><h4 id="塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到"><a href="#塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到" class="headerlink" title="塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到"></a>塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到</h4><h4 id="maximumPoolSize-最大线程数配置。此时，再多余的任务，则会触发线程池"><a href="#maximumPoolSize-最大线程数配置。此时，再多余的任务，则会触发线程池" class="headerlink" title="maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池"></a>maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池</h4><h4 id="的拒绝策略了。"><a href="#的拒绝策略了。" class="headerlink" title="的拒绝策略了。"></a>的拒绝策略了。</h4><h4 id="总结起来，也就是一句话，-当提交的任务数大于（workQueue-size"><a href="#总结起来，也就是一句话，-当提交的任务数大于（workQueue-size" class="headerlink" title="总结起来，也就是一句话， 当提交的任务数大于（workQueue.size() +"></a>总结起来，也就是一句话， 当提交的任务数大于（workQueue.size() +</h4><h4 id="maximumPoolSize-），就会触发线程池的拒绝策略-。"><a href="#maximumPoolSize-），就会触发线程池的拒绝策略-。" class="headerlink" title="maximumPoolSize ），就会触发线程池的拒绝策略 。"></a>maximumPoolSize ），就会触发线程池的拒绝策略 。</h4><h4 id="10-2-2-拒绝策略-重点"><a href="#10-2-2-拒绝策略-重点" class="headerlink" title="10 .2.2 拒绝策略(重点)"></a>10 .2.2 拒绝策略(重点)</h4><h4 id="CallerRunsPolicy-当触发拒绝策略，只要线程池没有关闭的话，则使用调用"><a href="#CallerRunsPolicy-当触发拒绝策略，只要线程池没有关闭的话，则使用调用" class="headerlink" title="CallerRunsPolicy : 当触发拒绝策略，只要线程池没有关闭的话，则使用调用"></a>CallerRunsPolicy : 当触发拒绝策略，只要线程池没有关闭的话，则使用调用</h4><h4 id="线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由"><a href="#线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由" class="headerlink" title="线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由"></a>线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由</h4><h4 id="于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效"><a href="#于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效" class="headerlink" title="于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效"></a>于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效</h4><h4 id="率上必然的损失较大"><a href="#率上必然的损失较大" class="headerlink" title="率上必然的损失较大"></a>率上必然的损失较大</h4><h4 id="AbortPolicy-丢弃任务，并抛出拒绝执行-RejectedExecutionException-异常"><a href="#AbortPolicy-丢弃任务，并抛出拒绝执行-RejectedExecutionException-异常" class="headerlink" title="AbortPolicy : 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常"></a>AbortPolicy : 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常</h4><h4 id="信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执"><a href="#信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执" class="headerlink" title="信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执"></a>信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执</h4><h4 id="行流程，影响后续的任务执行。"><a href="#行流程，影响后续的任务执行。" class="headerlink" title="行流程，影响后续的任务执行。"></a>行流程，影响后续的任务执行。</h4><h4 id="DiscardPolicy-直接丢弃，其他啥都没有"><a href="#DiscardPolicy-直接丢弃，其他啥都没有" class="headerlink" title="DiscardPolicy : 直接丢弃，其他啥都没有"></a>DiscardPolicy : 直接丢弃，其他啥都没有</h4><h4 id="DiscardOldestPolicy-当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞"><a href="#DiscardOldestPolicy-当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞" class="headerlink" title="DiscardOldestPolicy : 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞"></a>DiscardOldestPolicy : 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞</h4><h4 id="队列-workQueue-中最老的一个任务，并将新任务加入"><a href="#队列-workQueue-中最老的一个任务，并将新任务加入" class="headerlink" title="队列 workQueue 中最老的一个任务，并将新任务加入"></a>队列 workQueue 中最老的一个任务，并将新任务加入</h4><h4 id="10-3-线程池的种类与创建"><a href="#10-3-线程池的种类与创建" class="headerlink" title="10 .3 线程池的种类与创建"></a>10 .3 线程池的种类与创建</h4><h4 id="10-3-1-newCachedThreadPool-常用"><a href="#10-3-1-newCachedThreadPool-常用" class="headerlink" title="10 .3.1 newCachedThreadPool(常用)"></a>10 .3.1 newCachedThreadPool(常用)</h4><h4 id="作用-：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空"><a href="#作用-：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空" class="headerlink" title="作用 ：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空"></a>作用 ：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空</h4><h4 id="闲线程，若无可回收，则新建线程"><a href="#闲线程，若无可回收，则新建线程" class="headerlink" title="闲线程，若无可回收，则新建线程."></a>闲线程，若无可回收，则新建线程.</h4><h4 id="特点"><a href="#特点" class="headerlink" title="特点 :"></a>特点 :</h4><ul>
<li>线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE）</li>
<li>线程池中的线程可进行缓存重复利用和回收（回收默认时间为 1 分钟）</li>
<li>当线程池中，没有可用线程，会重新创建一个线程</li>
</ul>
<h4 id="创建方式："><a href="#创建方式：" class="headerlink" title="创建方式："></a>创建方式：</h4><h4 id="x2F-32"><a href="#x2F-32" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h4><h4 id="可缓存线程池"><a href="#可缓存线程池" class="headerlink" title="* 可缓存线程池"></a>* 可缓存线程池</h4><h4 id="return"><a href="#return" class="headerlink" title="* @return"></a>* @return</h4><h4 id="x2F-33"><a href="#x2F-33" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h4><h4 id="public-static-ExecutorService-newCachedThreadPool"><a href="#public-static-ExecutorService-newCachedThreadPool" class="headerlink" title="public static ExecutorService newCachedThreadPool(){"></a>public static ExecutorService newCachedThreadPool(){</h4><h4 id="x2F-34"><a href="#x2F-34" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h4><h4 id="corePoolSize线程池的核心线程数"><a href="#corePoolSize线程池的核心线程数" class="headerlink" title="* corePoolSize线程池的核心线程数"></a>* corePoolSize线程池的核心线程数</h4><h4 id="maximumPoolSize能容纳的最大线程数"><a href="#maximumPoolSize能容纳的最大线程数" class="headerlink" title="* maximumPoolSize能容纳的最大线程数"></a>* maximumPoolSize能容纳的最大线程数</h4><h4 id="keepAliveTime空闲线程存活时间"><a href="#keepAliveTime空闲线程存活时间" class="headerlink" title="* keepAliveTime空闲线程存活时间"></a>* keepAliveTime空闲线程存活时间</h4><h4 id="unit-存活的时间单位"><a href="#unit-存活的时间单位" class="headerlink" title="* unit 存活的时间单位"></a>* unit 存活的时间单位</h4><h4 id="workQueue-存放提交但未执行任务的队列"><a href="#workQueue-存放提交但未执行任务的队列" class="headerlink" title="* workQueue 存放提交但未执行任务的队列"></a>* workQueue 存放提交但未执行任务的队列</h4><h4 id="threadFactory-创建线程的工厂类-可以省略"><a href="#threadFactory-创建线程的工厂类-可以省略" class="headerlink" title="* threadFactory 创建线程的工厂类:可以省略"></a>* threadFactory 创建线程的工厂类:可以省略</h4><h4 id="handler-等待队列满后的拒绝策略-可以省略"><a href="#handler-等待队列满后的拒绝策略-可以省略" class="headerlink" title="* handler 等待队列满后的拒绝策略:可以省略"></a>* handler 等待队列满后的拒绝策略:可以省略</h4><h4 id="x2F-35"><a href="#x2F-35" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h4><h4 id="return-new-ThreadPoolExecutor-0"><a href="#return-new-ThreadPoolExecutor-0" class="headerlink" title="return new ThreadPoolExecutor( 0 ,"></a>return new ThreadPoolExecutor( 0 ,</h4><h4 id="Integer-MAX-VALUE"><a href="#Integer-MAX-VALUE" class="headerlink" title="Integer.MAX_VALUE,"></a>Integer.MAX_VALUE,</h4><h4 id="60L"><a href="#60L" class="headerlink" title="60L,"></a>60L,</h4><h4 id="TimeUnit-SECONDS"><a href="#TimeUnit-SECONDS" class="headerlink" title="TimeUnit.SECONDS,"></a>TimeUnit.SECONDS,</h4><h4 id="new-SynchronousQueue-lt-gt"><a href="#new-SynchronousQueue-lt-gt" class="headerlink" title="new SynchronousQueue&lt;&gt;(),"></a>new SynchronousQueue&lt;&gt;(),</h4><h4 id="Executors-defaultThreadFactory"><a href="#Executors-defaultThreadFactory" class="headerlink" title="Executors.defaultThreadFactory(),"></a>Executors.defaultThreadFactory(),</h4><h4 id="new-ThreadPoolExecutor-AbortPolicy"><a href="#new-ThreadPoolExecutor-AbortPolicy" class="headerlink" title="new ThreadPoolExecutor.AbortPolicy());"></a>new ThreadPoolExecutor.AbortPolicy());</h4><h4 id="-31"><a href="#-31" class="headerlink" title="}"></a>}</h4><h4 id="场景-适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较"><a href="#场景-适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较" class="headerlink" title="场景: 适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较"></a>场景: 适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较</h4><h4 id="短，任务多的场景"><a href="#短，任务多的场景" class="headerlink" title="短，任务多的场景"></a>短，任务多的场景</h4><h4 id="10-3-2-newFixedThreadPool-常用"><a href="#10-3-2-newFixedThreadPool-常用" class="headerlink" title="10 .3.2 newFixedThreadPool(常用)"></a>10 .3.2 newFixedThreadPool(常用)</h4><h4 id="作用-：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这"><a href="#作用-：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这" class="headerlink" title="作用 ：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这"></a>作用 ：创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这</h4><h4 id="些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线"><a href="#些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线" class="headerlink" title="些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线"></a>些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线</h4><h4 id="程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中"><a href="#程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中" class="headerlink" title="程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中"></a>程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中</h4><h4 id="等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线"><a href="#等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线" class="headerlink" title="等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线"></a>等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线</h4><h4 id="程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池"><a href="#程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池" class="headerlink" title="程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池"></a>程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池</h4><h4 id="中的线程将一直存在。"><a href="#中的线程将一直存在。" class="headerlink" title="中的线程将一直存在。"></a>中的线程将一直存在。</h4><h4 id="特征："><a href="#特征：" class="headerlink" title="特征："></a>特征：</h4><ul>
<li>线程池中的线程处于一定的量，可以很好的控制线程的并发量</li>
<li>线程可以重复被使用，在显示关闭之前，都将一直存在</li>
<li>超出一定量的线程被提交时候需在队列中等待</li>
</ul>
<h4 id="创建方式-："><a href="#创建方式-：" class="headerlink" title="创建方式 ："></a>创建方式 ：</h4><h4 id="x2F-36"><a href="#x2F-36" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h4><h4 id="固定长度线程池"><a href="#固定长度线程池" class="headerlink" title="* 固定长度线程池"></a>* 固定长度线程池</h4><h4 id="return-1"><a href="#return-1" class="headerlink" title="* @return"></a>* @return</h4><h4 id="x2F-37"><a href="#x2F-37" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h4><h4 id="public-static-ExecutorService-newFixedThreadPool"><a href="#public-static-ExecutorService-newFixedThreadPool" class="headerlink" title="public static ExecutorService newFixedThreadPool(){"></a>public static ExecutorService newFixedThreadPool(){</h4><h4 id="x2F-38"><a href="#x2F-38" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h4><h4 id="corePoolSize线程池的核心线程数-1"><a href="#corePoolSize线程池的核心线程数-1" class="headerlink" title="* corePoolSize线程池的核心线程数"></a>* corePoolSize线程池的核心线程数</h4><h4 id="maximumPoolSize能容纳的最大线程数-1"><a href="#maximumPoolSize能容纳的最大线程数-1" class="headerlink" title="* maximumPoolSize能容纳的最大线程数"></a>* maximumPoolSize能容纳的最大线程数</h4><h4 id="keepAliveTime空闲线程存活时间-1"><a href="#keepAliveTime空闲线程存活时间-1" class="headerlink" title="* keepAliveTime空闲线程存活时间"></a>* keepAliveTime空闲线程存活时间</h4><h4 id="unit-存活的时间单位-1"><a href="#unit-存活的时间单位-1" class="headerlink" title="* unit 存活的时间单位"></a>* unit 存活的时间单位</h4><h4 id="workQueue-存放提交但未执行任务的队列-1"><a href="#workQueue-存放提交但未执行任务的队列-1" class="headerlink" title="* workQueue 存放提交但未执行任务的队列"></a>* workQueue 存放提交但未执行任务的队列</h4><h4 id="threadFactory-创建线程的工厂类-可以省略-1"><a href="#threadFactory-创建线程的工厂类-可以省略-1" class="headerlink" title="* threadFactory 创建线程的工厂类:可以省略"></a>* threadFactory 创建线程的工厂类:可以省略</h4><h4 id="handler-等待队列满后的拒绝策略-可以省略-1"><a href="#handler-等待队列满后的拒绝策略-可以省略-1" class="headerlink" title="* handler 等待队列满后的拒绝策略:可以省略"></a>* handler 等待队列满后的拒绝策略:可以省略</h4><h4 id="x2F-39"><a href="#x2F-39" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h4><h4 id="return-new-ThreadPoolExecutor-10"><a href="#return-new-ThreadPoolExecutor-10" class="headerlink" title="return new ThreadPoolExecutor( 10 ,"></a>return new ThreadPoolExecutor( 10 ,</h4><h4 id="10"><a href="#10" class="headerlink" title="10 ,"></a>10 ,</h4><h4 id="0L"><a href="#0L" class="headerlink" title="0L,"></a>0L,</h4><h4 id="TimeUnit-SECONDS-1"><a href="#TimeUnit-SECONDS-1" class="headerlink" title="TimeUnit.SECONDS,"></a>TimeUnit.SECONDS,</h4><h4 id="new-LinkedBlockingQueue-lt-gt"><a href="#new-LinkedBlockingQueue-lt-gt" class="headerlink" title="new LinkedBlockingQueue&lt;&gt;(),"></a>new LinkedBlockingQueue&lt;&gt;(),</h4><h4 id="Executors-defaultThreadFactory-1"><a href="#Executors-defaultThreadFactory-1" class="headerlink" title="Executors.defaultThreadFactory(),"></a>Executors.defaultThreadFactory(),</h4><h4 id="new-ThreadPoolExecutor-AbortPolicy-1"><a href="#new-ThreadPoolExecutor-AbortPolicy-1" class="headerlink" title="new ThreadPoolExecutor.AbortPolicy());"></a>new ThreadPoolExecutor.AbortPolicy());</h4><h4 id="-32"><a href="#-32" class="headerlink" title="}"></a>}</h4><h4 id="场景-适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严"><a href="#场景-适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严" class="headerlink" title="场景: 适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严"></a>场景: 适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严</h4><h4 id="格限制的场景"><a href="#格限制的场景" class="headerlink" title="格限制的场景"></a>格限制的场景</h4><h4 id="10-3-3-newSingleThreadExecutor-常用"><a href="#10-3-3-newSingleThreadExecutor-常用" class="headerlink" title="10 .3.3 newSingleThreadExecutor(常用)"></a>10 .3.3 newSingleThreadExecutor(常用)</h4><h4 id="作用-：创建一个使用单个-worker-线程的-Executor，以无界队列方式来运行该"><a href="#作用-：创建一个使用单个-worker-线程的-Executor，以无界队列方式来运行该" class="headerlink" title="作用 ：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该"></a>作用 ：创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该</h4><h4 id="线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，"><a href="#线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，" class="headerlink" title="线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，"></a>线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，</h4><h4 id="那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各"><a href="#那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各" class="headerlink" title="那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各"></a>那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各</h4><h4 id="个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的"><a href="#个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的" class="headerlink" title="个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的"></a>个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的</h4><h4 id="newFixedThreadPool不同，可保证无需重新配置此方法所返回的执行程序即"><a href="#newFixedThreadPool不同，可保证无需重新配置此方法所返回的执行程序即" class="headerlink" title="newFixedThreadPool不同，可保证无需重新配置此方法所返回的执行程序即"></a>newFixedThreadPool不同，可保证无需重新配置此方法所返回的执行程序即</h4><h4 id="可使用其他的线程。"><a href="#可使用其他的线程。" class="headerlink" title="可使用其他的线程。"></a>可使用其他的线程。</h4><h4 id="特征：-线程池中最多执行-1-个线程，之后提交的线程活动将会排在队列中以此"><a href="#特征：-线程池中最多执行-1-个线程，之后提交的线程活动将会排在队列中以此" class="headerlink" title="特征： 线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此"></a>特征： 线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此</h4><h4 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h4><h4 id="创建方式：-1"><a href="#创建方式：-1" class="headerlink" title="创建方式："></a>创建方式：</h4><h4 id="x2F-40"><a href="#x2F-40" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h4><h4 id="单一线程池"><a href="#单一线程池" class="headerlink" title="* 单一线程池"></a>* 单一线程池</h4><h4 id="return-2"><a href="#return-2" class="headerlink" title="* @return"></a>* @return</h4><h4 id="x2F-41"><a href="#x2F-41" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h4><h4 id="public-static-ExecutorService-newSingleThreadExecutor"><a href="#public-static-ExecutorService-newSingleThreadExecutor" class="headerlink" title="public static ExecutorService newSingleThreadExecutor(){"></a>public static ExecutorService newSingleThreadExecutor(){</h4><h4 id="x2F-42"><a href="#x2F-42" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h4><h4 id="corePoolSize线程池的核心线程数-2"><a href="#corePoolSize线程池的核心线程数-2" class="headerlink" title="* corePoolSize线程池的核心线程数"></a>* corePoolSize线程池的核心线程数</h4><h4 id="maximumPoolSize能容纳的最大线程数-2"><a href="#maximumPoolSize能容纳的最大线程数-2" class="headerlink" title="* maximumPoolSize能容纳的最大线程数"></a>* maximumPoolSize能容纳的最大线程数</h4><h4 id="keepAliveTime空闲线程存活时间-2"><a href="#keepAliveTime空闲线程存活时间-2" class="headerlink" title="* keepAliveTime空闲线程存活时间"></a>* keepAliveTime空闲线程存活时间</h4><h4 id="unit-存活的时间单位-2"><a href="#unit-存活的时间单位-2" class="headerlink" title="* unit 存活的时间单位"></a>* unit 存活的时间单位</h4><h4 id="workQueue-存放提交但未执行任务的队列-2"><a href="#workQueue-存放提交但未执行任务的队列-2" class="headerlink" title="* workQueue 存放提交但未执行任务的队列"></a>* workQueue 存放提交但未执行任务的队列</h4><h4 id="threadFactory-创建线程的工厂类-可以省略-2"><a href="#threadFactory-创建线程的工厂类-可以省略-2" class="headerlink" title="* threadFactory 创建线程的工厂类:可以省略"></a>* threadFactory 创建线程的工厂类:可以省略</h4><h4 id="handler-等待队列满后的拒绝策略-可以省略-2"><a href="#handler-等待队列满后的拒绝策略-可以省略-2" class="headerlink" title="* handler 等待队列满后的拒绝策略:可以省略"></a>* handler 等待队列满后的拒绝策略:可以省略</h4><h4 id="x2F-43"><a href="#x2F-43" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h4><h4 id="return-new-ThreadPoolExecutor-1"><a href="#return-new-ThreadPoolExecutor-1" class="headerlink" title="return new ThreadPoolExecutor( 1 ,"></a>return new ThreadPoolExecutor( 1 ,</h4><h4 id="1"><a href="#1" class="headerlink" title="1 ,"></a>1 ,</h4><h4 id="0L-1"><a href="#0L-1" class="headerlink" title="0L,"></a>0L,</h4><h4 id="TimeUnit-SECONDS-2"><a href="#TimeUnit-SECONDS-2" class="headerlink" title="TimeUnit.SECONDS,"></a>TimeUnit.SECONDS,</h4><h4 id="new-LinkedBlockingQueue-lt-gt-1"><a href="#new-LinkedBlockingQueue-lt-gt-1" class="headerlink" title="new LinkedBlockingQueue&lt;&gt;(),"></a>new LinkedBlockingQueue&lt;&gt;(),</h4><h4 id="Executors-defaultThreadFactory-2"><a href="#Executors-defaultThreadFactory-2" class="headerlink" title="Executors.defaultThreadFactory(),"></a>Executors.defaultThreadFactory(),</h4><h4 id="new-ThreadPoolExecutor-AbortPolicy-2"><a href="#new-ThreadPoolExecutor-AbortPolicy-2" class="headerlink" title="new ThreadPoolExecutor.AbortPolicy());"></a>new ThreadPoolExecutor.AbortPolicy());</h4><h4 id="-33"><a href="#-33" class="headerlink" title="}"></a>}</h4><h4 id="场景-适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个"><a href="#场景-适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个" class="headerlink" title="场景: 适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个"></a>场景: 适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个</h4><h4 id="线程的场景"><a href="#线程的场景" class="headerlink" title="线程的场景"></a>线程的场景</h4><h4 id="10-3-4-newScheduleThreadPool-了解"><a href="#10-3-4-newScheduleThreadPool-了解" class="headerlink" title="10 .3.4 newScheduleThreadPool(了解)"></a>10 .3.4 newScheduleThreadPool(了解)</h4><h4 id="作用-线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参"><a href="#作用-线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参" class="headerlink" title="作用: 线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参"></a>作用: 线程池支持定时以及周期性执行任务，创建一个corePoolSize为传入参</h4><h4 id="数，最大线程数为整形的最大数的线程池"><a href="#数，最大线程数为整形的最大数的线程池" class="headerlink" title="数，最大线程数为整形的最大数的线程池**"></a>数，最大线程数为整形的最大数的线程池**</h4><h4 id="特征"><a href="#特征" class="headerlink" title="特征:"></a>特征:</h4><h4 id="（-1-）线程池中具有指定数量的线程，即便是空线程也将保留-（-2-）可定时或者"><a href="#（-1-）线程池中具有指定数量的线程，即便是空线程也将保留-（-2-）可定时或者" class="headerlink" title="（ 1 ）线程池中具有指定数量的线程，即便是空线程也将保留 （ 2 ）可定时或者"></a>（ 1 ）线程池中具有指定数量的线程，即便是空线程也将保留 （ 2 ）可定时或者</h4><h4 id="延迟执行线程活动"><a href="#延迟执行线程活动" class="headerlink" title="延迟执行线程活动"></a>延迟执行线程活动</h4><h4 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式:"></a>创建方式:</h4><h4 id="public-static-ScheduledExecutorService-newScheduledThreadPool-int"><a href="#public-static-ScheduledExecutorService-newScheduledThreadPool-int" class="headerlink" title="public static ScheduledExecutorService newScheduledThreadPool(int"></a>public static ScheduledExecutorService newScheduledThreadPool(int</h4><h4 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize,"></a>corePoolSize,</h4><h4 id="ThreadFactory-threadFactory"><a href="#ThreadFactory-threadFactory" class="headerlink" title="ThreadFactory threadFactory) {"></a>ThreadFactory threadFactory) {</h4><h4 id="return-new-ScheduledThreadPoolExecutor-corePoolSize"><a href="#return-new-ScheduledThreadPoolExecutor-corePoolSize" class="headerlink" title="return new ScheduledThreadPoolExecutor(corePoolSize,"></a>return new ScheduledThreadPoolExecutor(corePoolSize,</h4><h4 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory);"></a>threadFactory);</h4><h4 id="-34"><a href="#-34" class="headerlink" title="}"></a>}</h4><h4 id="场景-适用于需要多个后台线程执行周期任务的场景"><a href="#场景-适用于需要多个后台线程执行周期任务的场景" class="headerlink" title="场景: 适用于需要多个后台线程执行周期任务的场景"></a>场景: 适用于需要多个后台线程执行周期任务的场景</h4><h4 id="10-3-5-newWorkStealingPool"><a href="#10-3-5-newWorkStealingPool" class="headerlink" title="10 .3.5 newWorkStealingPool"></a>10 .3.5 newWorkStealingPool</h4><h4 id="jdk1-8提供的线程池，底层使用的是ForkJoinPool实现，创建一个拥有多个"><a href="#jdk1-8提供的线程池，底层使用的是ForkJoinPool实现，创建一个拥有多个" class="headerlink" title="jdk1.8提供的线程池，底层使用的是ForkJoinPool实现，创建一个拥有多个"></a>jdk1.8提供的线程池，底层使用的是ForkJoinPool实现，创建一个拥有多个</h4><h4 id="任务队列的线程池，可以减少连接数，创建当前可用cpu核数的线程来并行执"><a href="#任务队列的线程池，可以减少连接数，创建当前可用cpu核数的线程来并行执" class="headerlink" title="任务队列的线程池，可以减少连接数，创建当前可用cpu核数的线程来并行执"></a>任务队列的线程池，可以减少连接数，创建当前可用cpu核数的线程来并行执</h4><h4 id="行任务"><a href="#行任务" class="headerlink" title="行任务"></a>行任务</h4><h4 id="创建方式-1"><a href="#创建方式-1" class="headerlink" title="创建方式:"></a>创建方式:</h4><p>public static ExecutorService newWorkStealingPool(int parallelism) {<br>&#x2F;**</p>
<ul>
<li>parallelism：并行级别，通常默认为JVM可用的处理器个数</li>
<li>factory：用于创建ForkJoinPool中使用的线程。</li>
<li>handler：用于处理工作线程未处理的异常，默认为null</li>
<li>asyncMode：用于控制WorkQueue的工作模式:队列—反队列</li>
</ul>
<h5 id="x2F-44"><a href="#x2F-44" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h5><p>return new ForkJoinPool(parallelism,<br>ForkJoinPool.defaultForkJoinWorkerThreadFactory,<br>null,<br>true);<br>}</p>
<h4 id="场景-适用于大耗时，可并行执行的场景"><a href="#场景-适用于大耗时，可并行执行的场景" class="headerlink" title="场景: 适用于大耗时，可并行执行的场景"></a>场景: 适用于大耗时，可并行执行的场景</h4><h4 id="10-4-线程池入门案例"><a href="#10-4-线程池入门案例" class="headerlink" title="10 .4 线程池入门案例"></a>10 .4 线程池入门案例</h4><h4 id="场景-火车站-3-个售票口-10个用户买票"><a href="#场景-火车站-3-个售票口-10个用户买票" class="headerlink" title="场景: 火车站 3 个售票口, 10个用户买票"></a>场景: 火车站 3 个售票口, 10个用户买票</h4><h4 id="package-com-atguigu-test-1"><a href="#package-com-atguigu-test-1" class="headerlink" title="package com.atguigu.test;"></a>package com.atguigu.test;</h4><h4 id="import-java-util-concurrent"><a href="#import-java-util-concurrent" class="headerlink" title="import java.util.concurrent.*;"></a>import java.util.concurrent.*;</h4><h4 id="x2F-45"><a href="#x2F-45" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h4><h4 id="入门案例"><a href="#入门案例" class="headerlink" title="* 入门案例"></a>* 入门案例</h4><h4 id="x2F-46"><a href="#x2F-46" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h4><h4 id="public-class-ThreadPoolDemo1"><a href="#public-class-ThreadPoolDemo1" class="headerlink" title="public class ThreadPoolDemo1 {"></a>public class ThreadPoolDemo1 {</h4><h4 id="x2F-47"><a href="#x2F-47" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h4><h4 id="火车站-3-个售票口-10个用户买票"><a href="#火车站-3-个售票口-10个用户买票" class="headerlink" title="* 火车站 3 个售票口, 10个用户买票"></a>* 火车站 3 个售票口, 10个用户买票</h4><h4 id="param-args-1"><a href="#param-args-1" class="headerlink" title="* @param args"></a>* @param args</h4><h4 id="x2F-48"><a href="#x2F-48" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h4><h4 id="public-static-void-main-String-args-3"><a href="#public-static-void-main-String-args-3" class="headerlink" title="public static void main(String[] args) {"></a>public static void main(String[] args) {</h4><h4 id="x2F-x2F-定时线程次-线程数量为-3-—窗口数为-3"><a href="#x2F-x2F-定时线程次-线程数量为-3-—窗口数为-3" class="headerlink" title="&#x2F;&#x2F;定时线程次:线程数量为 3 —窗口数为 3"></a>&#x2F;&#x2F;定时线程次:线程数量为 3 —窗口数为 3</h4><h4 id="ExecutorService-threadService-x3D-new-ThreadPoolExecutor-3"><a href="#ExecutorService-threadService-x3D-new-ThreadPoolExecutor-3" class="headerlink" title="ExecutorService threadService &#x3D; new ThreadPoolExecutor( 3 ,"></a>ExecutorService threadService &#x3D; new ThreadPoolExecutor( 3 ,</h4><h4 id="3"><a href="#3" class="headerlink" title="3 ,"></a>3 ,</h4><h4 id="60L-1"><a href="#60L-1" class="headerlink" title="60L,"></a>60L,</h4><h4 id="TimeUnit-SECONDS-3"><a href="#TimeUnit-SECONDS-3" class="headerlink" title="TimeUnit.SECONDS,"></a>TimeUnit.SECONDS,</h4><h4 id="new-LinkedBlockingQueue-lt-gt-2"><a href="#new-LinkedBlockingQueue-lt-gt-2" class="headerlink" title="new LinkedBlockingQueue&lt;&gt;(),"></a>new LinkedBlockingQueue&lt;&gt;(),</h4><h4 id="Executors-defaultThreadFactory-3"><a href="#Executors-defaultThreadFactory-3" class="headerlink" title="Executors.defaultThreadFactory(),"></a>Executors.defaultThreadFactory(),</h4><h4 id="new-ThreadPoolExecutor-DiscardOldestPolicy"><a href="#new-ThreadPoolExecutor-DiscardOldestPolicy" class="headerlink" title="new ThreadPoolExecutor.DiscardOldestPolicy());"></a>new ThreadPoolExecutor.DiscardOldestPolicy());</h4><h4 id="try-1"><a href="#try-1" class="headerlink" title="try {"></a>try {</h4><h4 id="x2F-x2F-10个人买票"><a href="#x2F-x2F-10个人买票" class="headerlink" title="&#x2F;&#x2F;10个人买票"></a>&#x2F;&#x2F;10个人买票</h4><h4 id="for-int-i-x3D-1-i-lt-x3D-10-i"><a href="#for-int-i-x3D-1-i-lt-x3D-10-i" class="headerlink" title="for (int i &#x3D; 1 ; i &lt;&#x3D; 10 ; i++) {"></a>for (int i &#x3D; 1 ; i &lt;&#x3D; 10 ; i++) {</h4><h4 id="threadService-execute-gt"><a href="#threadService-execute-gt" class="headerlink" title="threadService.execute(()-&gt;{"></a>threadService.execute(()-&gt;{</h4><h4 id="try-2"><a href="#try-2" class="headerlink" title="try {"></a>try {</h4><h4 id="System-out-println-Thread-currentThread-getName-“"><a href="#System-out-println-Thread-currentThread-getName-“" class="headerlink" title="System.out.println(Thread.currentThread().getName() + “"></a>System.out.println(Thread.currentThread().getName() + “</h4><h4 id="窗口-开始卖票”"><a href="#窗口-开始卖票”" class="headerlink" title="窗口,开始卖票”);"></a>窗口,开始卖票”);</h4><h4 id="Thread-sleep-5000"><a href="#Thread-sleep-5000" class="headerlink" title="Thread.sleep( 5000 );"></a>Thread.sleep( 5000 );</h4><h4 id="System-out-println-Thread-currentThread-getName-“-1"><a href="#System-out-println-Thread-currentThread-getName-“-1" class="headerlink" title="System.out.println(Thread.currentThread().getName() + “"></a>System.out.println(Thread.currentThread().getName() + “</h4><h4 id="窗口买票结束”"><a href="#窗口买票结束”" class="headerlink" title="窗口买票结束”);"></a>窗口买票结束”);</h4><h4 id="catch-Exception-e"><a href="#catch-Exception-e" class="headerlink" title="}catch (Exception e){"></a>}catch (Exception e){</h4><h4 id="e-printStackTrace"><a href="#e-printStackTrace" class="headerlink" title="e.printStackTrace();"></a>e.printStackTrace();</h4><h4 id="-35"><a href="#-35" class="headerlink" title="}"></a>}</h4><h4 id="-36"><a href="#-36" class="headerlink" title="});"></a>});</h4><h4 id="-37"><a href="#-37" class="headerlink" title="}"></a>}</h4><h4 id="catch-Exception-e-1"><a href="#catch-Exception-e-1" class="headerlink" title="}catch (Exception e){"></a>}catch (Exception e){</h4><h4 id="e-printStackTrace-1"><a href="#e-printStackTrace-1" class="headerlink" title="e.printStackTrace();"></a>e.printStackTrace();</h4><h4 id="finally-1"><a href="#finally-1" class="headerlink" title="}finally {"></a>}finally {</h4><h4 id="x2F-x2F-完成后结束"><a href="#x2F-x2F-完成后结束" class="headerlink" title="&#x2F;&#x2F;完成后结束"></a>&#x2F;&#x2F;完成后结束</h4><h4 id="threadService-shutdown"><a href="#threadService-shutdown" class="headerlink" title="threadService.shutdown();"></a>threadService.shutdown();</h4><h4 id="-38"><a href="#-38" class="headerlink" title="}"></a>}</h4><h4 id="-39"><a href="#-39" class="headerlink" title="}"></a>}</h4><h4 id="-40"><a href="#-40" class="headerlink" title="}"></a>}</h4><h4 id="10-5-线程池底层工作原理-重要"><a href="#10-5-线程池底层工作原理-重要" class="headerlink" title="10 .5 线程池底层工作原理(重要)"></a>10 .5 线程池底层工作原理(重要)</h4><h4 id="1-在创建了线程池后，线程池中的线程数为零"><a href="#1-在创建了线程池后，线程池中的线程数为零" class="headerlink" title="1. 在创建了线程池后，线程池中的线程数为零"></a>1. 在创建了线程池后，线程池中的线程数为零</h4><h4 id="2-当调用execute-方法添加一个请求任务时，线程池会做出如下判断：-2-1-如"><a href="#2-当调用execute-方法添加一个请求任务时，线程池会做出如下判断：-2-1-如" class="headerlink" title="2. 当调用execute()方法添加一个请求任务时，线程池会做出如下判断： 2.1 如"></a>2. 当调用execute()方法添加一个请求任务时，线程池会做出如下判断： 2.1 如</h4><h4 id="果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；"><a href="#果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；" class="headerlink" title="果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；"></a>果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；</h4><h4 id="2-2-如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入"><a href="#2-2-如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入" class="headerlink" title="2.2 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入"></a>2.2 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入</h4><h4 id="队列；-2-3-如果这个时候队列满了且正在运行的线程数量还小于"><a href="#队列；-2-3-如果这个时候队列满了且正在运行的线程数量还小于" class="headerlink" title="队列； 2.3 如果这个时候队列满了且正在运行的线程数量还小于"></a>队列； 2.3 如果这个时候队列满了且正在运行的线程数量还小于</h4><h4 id="maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；-2-4-如"><a href="#maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；-2-4-如" class="headerlink" title="maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； 2.4 如"></a>maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； 2.4 如</h4><h4 id="果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程"><a href="#果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程" class="headerlink" title="果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程"></a>果队列满了且正在运行的线程数量大于或等于maximumPoolSize，那么线程</h4><h4 id="池会启动饱和拒绝策略来执行。"><a href="#池会启动饱和拒绝策略来执行。" class="headerlink" title="池会启动饱和拒绝策略来执行。"></a>池会启动饱和拒绝策略来执行。</h4><h4 id="3-当一个线程完成任务时，它会从队列中取下一个任务来执行"><a href="#3-当一个线程完成任务时，它会从队列中取下一个任务来执行" class="headerlink" title="3. 当一个线程完成任务时，它会从队列中取下一个任务来执行"></a>3. 当一个线程完成任务时，它会从队列中取下一个任务来执行</h4><h4 id="4-当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断："><a href="#4-当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：" class="headerlink" title="4. 当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断："></a>4. 当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：</h4><h4 id="4-1-如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。-4-2"><a href="#4-1-如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。-4-2" class="headerlink" title="4.1 如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。 4.2"></a>4.1 如果当前运行的线程数大于corePoolSize，那么这个线程就被停掉。 4.2</h4><h4 id="所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。"><a href="#所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。" class="headerlink" title="所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。"></a>所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。</h4><h4 id="10-6-注意事项-重要"><a href="#10-6-注意事项-重要" class="headerlink" title="10 .6 注意事项(重要)"></a>10 .6 注意事项(重要)</h4><h4 id="1-项目中创建多线程时，使用常见的三种线程池创建方式，单一、可变、定长都"><a href="#1-项目中创建多线程时，使用常见的三种线程池创建方式，单一、可变、定长都" class="headerlink" title="1. 项目中创建多线程时，使用常见的三种线程池创建方式，单一、可变、定长都"></a>1. 项目中创建多线程时，使用常见的三种线程池创建方式，单一、可变、定长都</h4><h4 id="有一定问题，原因是FixedThreadPool和SingleThreadExecutor底层都是用"><a href="#有一定问题，原因是FixedThreadPool和SingleThreadExecutor底层都是用" class="headerlink" title="有一定问题，原因是FixedThreadPool和SingleThreadExecutor底层都是用"></a>有一定问题，原因是FixedThreadPool和SingleThreadExecutor底层都是用</h4><h4 id="LinkedBlockingQueue实现的，这个队列最大长度为Integer-MAX-VALUE，"><a href="#LinkedBlockingQueue实现的，这个队列最大长度为Integer-MAX-VALUE，" class="headerlink" title="LinkedBlockingQueue实现的，这个队列最大长度为Integer.MAX_VALUE，"></a>LinkedBlockingQueue实现的，这个队列最大长度为Integer.MAX_VALUE，</h4><h4 id="容易导致OOM。所以实际生产一般自己通过ThreadPoolExecutor的-7-个参"><a href="#容易导致OOM。所以实际生产一般自己通过ThreadPoolExecutor的-7-个参" class="headerlink" title="容易导致OOM。所以实际生产一般自己通过ThreadPoolExecutor的 7 个参"></a>容易导致OOM。所以实际生产一般自己通过ThreadPoolExecutor的 7 个参</h4><h4 id="数，自定义线程池"><a href="#数，自定义线程池" class="headerlink" title="数，自定义线程池"></a>数，自定义线程池</h4><h4 id="2-创建线程池推荐适用ThreadPoolExecutor及其-7-个参数手动创建"><a href="#2-创建线程池推荐适用ThreadPoolExecutor及其-7-个参数手动创建" class="headerlink" title="2. 创建线程池推荐适用ThreadPoolExecutor及其 7 个参数手动创建"></a>2. 创建线程池推荐适用ThreadPoolExecutor及其 7 个参数手动创建</h4><h4 id="o-corePoolSize线程池的核心线程数"><a href="#o-corePoolSize线程池的核心线程数" class="headerlink" title="o corePoolSize线程池的核心线程数"></a>o corePoolSize线程池的核心线程数</h4><h4 id="o-maximumPoolSize能容纳的最大线程数"><a href="#o-maximumPoolSize能容纳的最大线程数" class="headerlink" title="o maximumPoolSize能容纳的最大线程数"></a>o maximumPoolSize能容纳的最大线程数</h4><h4 id="o-keepAliveTime空闲线程存活时间"><a href="#o-keepAliveTime空闲线程存活时间" class="headerlink" title="o keepAliveTime空闲线程存活时间"></a>o keepAliveTime空闲线程存活时间</h4><h4 id="o-unit-存活的时间单位"><a href="#o-unit-存活的时间单位" class="headerlink" title="o unit 存活的时间单位"></a>o unit 存活的时间单位</h4><h4 id="o-workQueue-存放提交但未执行任务的队列"><a href="#o-workQueue-存放提交但未执行任务的队列" class="headerlink" title="o workQueue 存放提交但未执行任务的队列"></a>o workQueue 存放提交但未执行任务的队列</h4><h4 id="o-threadFactory-创建线程的工厂类"><a href="#o-threadFactory-创建线程的工厂类" class="headerlink" title="o threadFactory 创建线程的工厂类"></a>o threadFactory 创建线程的工厂类</h4><h4 id="o-handler-等待队列满后的拒绝策略"><a href="#o-handler-等待队列满后的拒绝策略" class="headerlink" title="o handler 等待队列满后的拒绝策略"></a>o handler 等待队列满后的拒绝策略</h4><h4 id="3-为什么不允许适用不允许Executors-的方式手动创建线程池-如下图"><a href="#3-为什么不允许适用不允许Executors-的方式手动创建线程池-如下图" class="headerlink" title="3. 为什么不允许适用不允许Executors.的方式手动创建线程池,如下图"></a>3. 为什么不允许适用不允许Executors.的方式手动创建线程池,如下图</h4><h1 id="11-Fork-x2F-Join"><a href="#11-Fork-x2F-Join" class="headerlink" title="11 Fork&#x2F;Join"></a>11 Fork&#x2F;Join</h1><h4 id="11-1-Fork-x2F-Join框架简介"><a href="#11-1-Fork-x2F-Join框架简介" class="headerlink" title="11 .1 Fork&#x2F;Join框架简介"></a>11 .1 Fork&#x2F;Join框架简介</h4><h4 id="Fork-x2F-Join它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子"><a href="#Fork-x2F-Join它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子" class="headerlink" title="Fork&#x2F;Join它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子"></a>Fork&#x2F;Join它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子</h4><h4 id="任务结果合并成最后的计算结果，并进行输出。Fork-x2F-Join框架要完成两件事"><a href="#任务结果合并成最后的计算结果，并进行输出。Fork-x2F-Join框架要完成两件事" class="headerlink" title="任务结果合并成最后的计算结果，并进行输出。Fork&#x2F;Join框架要完成两件事"></a>任务结果合并成最后的计算结果，并进行输出。Fork&#x2F;Join框架要完成两件事</h4><h4 id="情："><a href="#情：" class="headerlink" title="情："></a>情：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fork：把一个复杂任务进行分拆，大事化小</span><br><span class="line">Join：把分拆任务的结果进行合并</span><br></pre></td></tr></table></figure>
<h4 id="1-任务分割-：首先Fork-x2F-Join框架需要把大的任务分割成足够小的子任务，如果"><a href="#1-任务分割-：首先Fork-x2F-Join框架需要把大的任务分割成足够小的子任务，如果" class="headerlink" title="1. 任务分割 ：首先Fork&#x2F;Join框架需要把大的任务分割成足够小的子任务，如果"></a>1. 任务分割 ：首先Fork&#x2F;Join框架需要把大的任务分割成足够小的子任务，如果</h4><h4 id="子任务比较大的话还要对子任务进行继续分割"><a href="#子任务比较大的话还要对子任务进行继续分割" class="headerlink" title="子任务比较大的话还要对子任务进行继续分割"></a>子任务比较大的话还要对子任务进行继续分割</h4><h4 id="2-执行任务并合并结果-：分割的子任务分别放到双端队列里，然后几个启动线程"><a href="#2-执行任务并合并结果-：分割的子任务分别放到双端队列里，然后几个启动线程" class="headerlink" title="2. 执行任务并合并结果 ：分割的子任务分别放到双端队列里，然后几个启动线程"></a>2. 执行任务并合并结果 ：分割的子任务分别放到双端队列里，然后几个启动线程</h4><h4 id="分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，"><a href="#分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，" class="headerlink" title="分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，"></a>分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，</h4><h4 id="启动一个线程从队列里取数据，然后合并这些数据。"><a href="#启动一个线程从队列里取数据，然后合并这些数据。" class="headerlink" title="启动一个线程从队列里取数据，然后合并这些数据。"></a>启动一个线程从队列里取数据，然后合并这些数据。</h4><h4 id="在Java的Fork-x2F-Join框架中，使用两个类完成上述操作"><a href="#在Java的Fork-x2F-Join框架中，使用两个类完成上述操作" class="headerlink" title="在Java的Fork&#x2F;Join框架中，使用两个类完成上述操作"></a>在Java的Fork&#x2F;Join框架中，使用两个类完成上述操作</h4><ul>
<li><strong>ForkJoinTask</strong> :我们要使用Fork&#x2F;Join框架，首先需要创建一个ForkJoin任务。</li>
</ul>
<h4 id="该类提供了在任务中执行fork和join的机制。通常情况下我们不需要直接集"><a href="#该类提供了在任务中执行fork和join的机制。通常情况下我们不需要直接集" class="headerlink" title="该类提供了在任务中执行fork和join的机制。通常情况下我们不需要直接集"></a>该类提供了在任务中执行fork和join的机制。通常情况下我们不需要直接集</h4><h4 id="成ForkJoinTask类，只需要继承它的子类，Fork-x2F-Join框架提供了两个子类："><a href="#成ForkJoinTask类，只需要继承它的子类，Fork-x2F-Join框架提供了两个子类：" class="headerlink" title="成ForkJoinTask类，只需要继承它的子类，Fork&#x2F;Join框架提供了两个子类："></a>成ForkJoinTask类，只需要继承它的子类，Fork&#x2F;Join框架提供了两个子类：</h4><h4 id="a-RecursiveAction：用于没有返回结果的任务"><a href="#a-RecursiveAction：用于没有返回结果的任务" class="headerlink" title="a.RecursiveAction：用于没有返回结果的任务"></a>a.RecursiveAction：用于没有返回结果的任务</h4><h4 id="b-RecursiveTask-用于有返回结果的任务"><a href="#b-RecursiveTask-用于有返回结果的任务" class="headerlink" title="b.RecursiveTask:用于有返回结果的任务"></a>b.RecursiveTask:用于有返回结果的任务</h4><ul>
<li><strong>ForkJoinPool</strong> :ForkJoinTask需要通过ForkJoinPool来执行</li>
<li><strong>RecursiveTask</strong> : 继承后可以实现递归(自己调自己)调用的任务</li>
</ul>
<h4 id="Fork-x2F-Join框架的实现原理"><a href="#Fork-x2F-Join框架的实现原理" class="headerlink" title="Fork&#x2F;Join框架的实现原理"></a>Fork&#x2F;Join框架的实现原理</h4><h4 id="ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，"><a href="#ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，" class="headerlink" title="ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，"></a>ForkJoinPool由ForkJoinTask数组和ForkJoinWorkerThread数组组成，</h4><h4 id="ForkJoinTask数组负责将存放以及将程序提交给ForkJoinPool，而"><a href="#ForkJoinTask数组负责将存放以及将程序提交给ForkJoinPool，而" class="headerlink" title="ForkJoinTask数组负责将存放以及将程序提交给ForkJoinPool，而"></a>ForkJoinTask数组负责将存放以及将程序提交给ForkJoinPool，而</h4><h4 id="ForkJoinWorkerThread负责执行这些任务。"><a href="#ForkJoinWorkerThread负责执行这些任务。" class="headerlink" title="ForkJoinWorkerThread负责执行这些任务。"></a>ForkJoinWorkerThread负责执行这些任务。</h4><h4 id="11-2-Fork方法"><a href="#11-2-Fork方法" class="headerlink" title="11 .2 Fork方法"></a>11 .2 Fork方法</h4><h4 id="Fork方法的实现原理：-当我们调用ForkJoinTask的fork方法时，程序会把"><a href="#Fork方法的实现原理：-当我们调用ForkJoinTask的fork方法时，程序会把" class="headerlink" title="Fork方法的实现原理： 当我们调用ForkJoinTask的fork方法时，程序会把"></a>Fork方法的实现原理： 当我们调用ForkJoinTask的fork方法时，程序会把</h4><h4 id="任务放在ForkJoinWorkerThread的pushTask的-workQueue-中，异步地"><a href="#任务放在ForkJoinWorkerThread的pushTask的-workQueue-中，异步地" class="headerlink" title="任务放在ForkJoinWorkerThread的pushTask的 workQueue 中，异步地"></a>任务放在ForkJoinWorkerThread的pushTask的 workQueue 中，异步地</h4><h4 id="执行这个任务，然后立即返回结果"><a href="#执行这个任务，然后立即返回结果" class="headerlink" title="执行这个任务，然后立即返回结果"></a>执行这个任务，然后立即返回结果</h4><p>public final ForkJoinTask<V> fork() {<br>Thread t;<br>if ((t &#x3D; Thread.currentThread()) instanceof ForkJoinWorkerThread)<br>((ForkJoinWorkerThread)t).workQueue.push(this);<br>else<br>ForkJoinPool.common.externalPush(this);<br>return this;<br>}</p>
<h4 id="pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用"><a href="#pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用" class="headerlink" title="pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用"></a>pushTask方法把当前任务存放在ForkJoinTask数组队列里。然后再调用</h4><h4 id="ForkJoinPool的signalWork-方法唤醒或创建一个工作线程来执行任务。代"><a href="#ForkJoinPool的signalWork-方法唤醒或创建一个工作线程来执行任务。代" class="headerlink" title="ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。代"></a>ForkJoinPool的signalWork()方法唤醒或创建一个工作线程来执行任务。代</h4><h4 id="码如下："><a href="#码如下：" class="headerlink" title="码如下："></a>码如下：</h4><p>final void push(ForkJoinTask<?> task) {
ForkJoinTask<?>[] a; ForkJoinPool p;<br>int b &#x3D; base, s &#x3D; top, n;<br>if ((a &#x3D; array) !&#x3D; null) { &#x2F;&#x2F; ignore if queue removed<br>int m &#x3D; a.length - 1 ; &#x2F;&#x2F; fenced write for task visibility<br>U.putOrderedObject(a, ((m &amp; s) &lt;&lt; ASHIFT) + ABASE, task);</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">U.putOrderedInt(this, QTOP, s + 1 );</span><br><span class="line">if ((n = s - b) &lt;= 1 ) &#123;</span><br><span class="line">if ((p = pool) != null)</span><br><span class="line">p.signalWork(p.workQueues, this);//执行</span><br><span class="line">&#125;</span><br><span class="line">else if (n &gt;= m)</span><br><span class="line">growArray();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-3-join方法"><a href="#11-3-join方法" class="headerlink" title="11 .3 join方法"></a>11 .3 join方法</h4><h4 id="Join方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看"><a href="#Join方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看" class="headerlink" title="Join方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看"></a>Join方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看</h4><h4 id="ForkJoinTask的join方法的实现，代码如下："><a href="#ForkJoinTask的join方法的实现，代码如下：" class="headerlink" title="ForkJoinTask的join方法的实现，代码如下："></a>ForkJoinTask的join方法的实现，代码如下：</h4><h4 id="public-final-V-join"><a href="#public-final-V-join" class="headerlink" title="public final V join() {"></a>public final V join() {</h4><h4 id="int-s"><a href="#int-s" class="headerlink" title="int s;"></a>int s;</h4><h4 id="if-s-x3D-doJoin-amp-DONE-MASK-x3D-NORMAL"><a href="#if-s-x3D-doJoin-amp-DONE-MASK-x3D-NORMAL" class="headerlink" title="if ((s &#x3D; doJoin() &amp; DONE_MASK) !&#x3D; NORMAL)"></a>if ((s &#x3D; doJoin() &amp; DONE_MASK) !&#x3D; NORMAL)</h4><h4 id="reportException-s"><a href="#reportException-s" class="headerlink" title="reportException(s);"></a>reportException(s);</h4><h4 id="return-getRawResult"><a href="#return-getRawResult" class="headerlink" title="return getRawResult();"></a>return getRawResult();</h4><h4 id="-41"><a href="#-41" class="headerlink" title="}"></a>}</h4><h4 id="它首先调用doJoin方法，通过doJoin-方法得到当前任务的状态来判断返回"><a href="#它首先调用doJoin方法，通过doJoin-方法得到当前任务的状态来判断返回" class="headerlink" title="它首先调用doJoin方法，通过doJoin()方法得到当前任务的状态来判断返回"></a>它首先调用doJoin方法，通过doJoin()方法得到当前任务的状态来判断返回</h4><h4 id="什么结果，任务状态有-4-种："><a href="#什么结果，任务状态有-4-种：" class="headerlink" title="什么结果，任务状态有 4 种："></a>什么结果，任务状态有 4 种：</h4><h4 id="x3D-x3D-已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出"><a href="#x3D-x3D-已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出" class="headerlink" title="&#x3D;&#x3D;已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出"></a>&#x3D;&#x3D;已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出</h4><h4 id="现异常（EXCEPTIONAL）-x3D-x3D"><a href="#现异常（EXCEPTIONAL）-x3D-x3D" class="headerlink" title="现异常（EXCEPTIONAL）&#x3D;&#x3D;"></a>现异常（EXCEPTIONAL）&#x3D;&#x3D;</h4><ul>
<li>如果任务状态是已完成，则直接返回任务结果。</li>
<li>如果任务状态是被取消，则直接抛出CancellationException</li>
<li>如果任务状态是抛出异常，则直接抛出对应的异常</li>
</ul>
<h4 id="让我们分析一下doJoin方法的实现"><a href="#让我们分析一下doJoin方法的实现" class="headerlink" title="让我们分析一下doJoin方法的实现"></a>让我们分析一下doJoin方法的实现</h4><h4 id="private-int-doJoin"><a href="#private-int-doJoin" class="headerlink" title="private int doJoin() {"></a>private int doJoin() {</h4><h4 id="int-s-Thread-t-ForkJoinWorkerThread-wt-ForkJoinPool-WorkQueue"><a href="#int-s-Thread-t-ForkJoinWorkerThread-wt-ForkJoinPool-WorkQueue" class="headerlink" title="int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue"></a>int s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue</h4><h4 id="w"><a href="#w" class="headerlink" title="w;"></a>w;</h4><h4 id="return-s-x3D-status-lt-0-s"><a href="#return-s-x3D-status-lt-0-s" class="headerlink" title="return (s &#x3D; status) &lt; 0? s :"></a>return (s &#x3D; status) &lt; 0? s :</h4><h4 id="t-x3D-Thread-currentThread-instanceof-ForkJoinWorkerThread"><a href="#t-x3D-Thread-currentThread-instanceof-ForkJoinWorkerThread" class="headerlink" title="((t &#x3D; Thread.currentThread()) instanceof ForkJoinWorkerThread)?"></a>((t &#x3D; Thread.currentThread()) instanceof ForkJoinWorkerThread)?</h4><h4 id="w-x3D-wt-x3D-ForkJoinWorkerThread-t-workQueue"><a href="#w-x3D-wt-x3D-ForkJoinWorkerThread-t-workQueue" class="headerlink" title="(w &#x3D; (wt &#x3D; (ForkJoinWorkerThread)t).workQueue)."></a>(w &#x3D; (wt &#x3D; (ForkJoinWorkerThread)t).workQueue).</h4><h4 id="tryUnpush-this-amp-amp-s-x3D-doExec-lt-0-s"><a href="#tryUnpush-this-amp-amp-s-x3D-doExec-lt-0-s" class="headerlink" title="tryUnpush(this) &amp;&amp; (s &#x3D; doExec()) &lt; 0? s :"></a>tryUnpush(this) &amp;&amp; (s &#x3D; doExec()) &lt; 0? s :</h4><h4 id="wt-pool-awaitJoin-w-this-0L"><a href="#wt-pool-awaitJoin-w-this-0L" class="headerlink" title="wt.pool.awaitJoin(w, this, 0L) :"></a>wt.pool.awaitJoin(w, this, 0L) :</h4><h4 id="externalAwaitDone"><a href="#externalAwaitDone" class="headerlink" title="externalAwaitDone();"></a>externalAwaitDone();</h4><h4 id="-42"><a href="#-42" class="headerlink" title="}"></a>}</h4><h4 id="final-int-doExec"><a href="#final-int-doExec" class="headerlink" title="final int doExec() {"></a>final int doExec() {</h4><h4 id="int-s-boolean-completed"><a href="#int-s-boolean-completed" class="headerlink" title="int s; boolean completed;"></a>int s; boolean completed;</h4><h4 id="if-s-x3D-status-gt-x3D-0"><a href="#if-s-x3D-status-gt-x3D-0" class="headerlink" title="if ((s &#x3D; status) &gt;&#x3D; 0 ) {"></a>if ((s &#x3D; status) &gt;&#x3D; 0 ) {</h4><h4 id="try-3"><a href="#try-3" class="headerlink" title="try {"></a>try {</h4><h4 id="completed-x3D-exec"><a href="#completed-x3D-exec" class="headerlink" title="completed &#x3D; exec();"></a>completed &#x3D; exec();</h4><h4 id="catch-Throwable-rex"><a href="#catch-Throwable-rex" class="headerlink" title="} catch (Throwable rex) {"></a>} catch (Throwable rex) {</h4><h4 id="return-setExceptionalCompletion-rex"><a href="#return-setExceptionalCompletion-rex" class="headerlink" title="return setExceptionalCompletion(rex);"></a>return setExceptionalCompletion(rex);</h4><h4 id="-43"><a href="#-43" class="headerlink" title="}"></a>}</h4><h4 id="if-completed"><a href="#if-completed" class="headerlink" title="if (completed)"></a>if (completed)</h4><h4 id="s-x3D-setCompletion-NORMAL"><a href="#s-x3D-setCompletion-NORMAL" class="headerlink" title="s &#x3D; setCompletion(NORMAL);"></a>s &#x3D; setCompletion(NORMAL);</h4><h4 id="-44"><a href="#-44" class="headerlink" title="}"></a>}</h4><h4 id="return-s"><a href="#return-s" class="headerlink" title="return s;"></a>return s;</h4><h4 id="-45"><a href="#-45" class="headerlink" title="}"></a>}</h4><h4 id="在doJoin-方法流程如下"><a href="#在doJoin-方法流程如下" class="headerlink" title="在doJoin()方法流程如下:"></a>在doJoin()方法流程如下:</h4><h4 id="1-首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接"><a href="#1-首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接" class="headerlink" title="1. 首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接"></a>1. 首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接</h4><h4 id="返回任务状态；"><a href="#返回任务状态；" class="headerlink" title="返回任务状态；"></a>返回任务状态；</h4><h4 id="2-如果没有执行完，则从任务数组里取出任务并执行。"><a href="#2-如果没有执行完，则从任务数组里取出任务并执行。" class="headerlink" title="2. 如果没有执行完，则从任务数组里取出任务并执行。"></a>2. 如果没有执行完，则从任务数组里取出任务并执行。</h4><h4 id="3-如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记"><a href="#3-如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记" class="headerlink" title="3. 如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记"></a>3. 如果任务顺利执行完成，则设置任务状态为NORMAL，如果出现异常，则记</h4><h4 id="录异常，并将任务状态设置为EXCEPTIONAL。"><a href="#录异常，并将任务状态设置为EXCEPTIONAL。" class="headerlink" title="录异常，并将任务状态设置为EXCEPTIONAL。"></a>录异常，并将任务状态设置为EXCEPTIONAL。</h4><h4 id="11-4-Fork-x2F-Join框架的异常处理"><a href="#11-4-Fork-x2F-Join框架的异常处理" class="headerlink" title="11 .4 Fork&#x2F;Join框架的异常处理"></a>11 .4 Fork&#x2F;Join框架的异常处理</h4><h4 id="ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接"><a href="#ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接" class="headerlink" title="ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接"></a>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接</h4><h4 id="捕获异常，所以ForkJoinTask提供了isCompletedAbnormally-方法来检查"><a href="#捕获异常，所以ForkJoinTask提供了isCompletedAbnormally-方法来检查" class="headerlink" title="捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查"></a>捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查</h4><h4 id="任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的"><a href="#任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的" class="headerlink" title="任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的"></a>任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的</h4><h4 id="getException方法获取异常。"><a href="#getException方法获取异常。" class="headerlink" title="getException方法获取异常。"></a>getException方法获取异常。</h4><h4 id="getException方法返回Throwable对象，如果任务被取消了则返回"><a href="#getException方法返回Throwable对象，如果任务被取消了则返回" class="headerlink" title="getException方法返回Throwable对象，如果任务被取消了则返回"></a>getException方法返回Throwable对象，如果任务被取消了则返回</h4><h4 id="CancellationException。如果任务没有完成或者没有抛出异常则返回null。"><a href="#CancellationException。如果任务没有完成或者没有抛出异常则返回null。" class="headerlink" title="CancellationException。如果任务没有完成或者没有抛出异常则返回null。"></a>CancellationException。如果任务没有完成或者没有抛出异常则返回null。</h4><h4 id="11-5-入门案例"><a href="#11-5-入门案例" class="headerlink" title="11 .5 入门案例"></a>11 .5 入门案例</h4><h4 id="场景-生成一个计算任务，计算1-2-3………-1000-x3D-x3D-每-100-个数切分一个"><a href="#场景-生成一个计算任务，计算1-2-3………-1000-x3D-x3D-每-100-个数切分一个" class="headerlink" title="场景: 生成一个计算任务，计算1+2+3………+1000 , &#x3D;&#x3D;每 100 个数切分一个"></a>场景: 生成一个计算任务，计算1+2+3………+1000 , &#x3D;&#x3D;每 100 个数切分一个</h4><h4 id="子任务-x3D-x3D"><a href="#子任务-x3D-x3D" class="headerlink" title="子任务&#x3D;&#x3D;"></a>子任务&#x3D;&#x3D;</h4><p>package com.atguigu.test;</p>
<p>import java.util.concurrent.RecursiveTask;</p>
<p>&#x2F;**</p>
<ul>
<li>递归累加<br><em>&#x2F;<br>public class TaskExample extends RecursiveTask<Long> {<br>private int start;<br>private int end;<br>private long sum;<br>&#x2F;</em>*</li>
<li>构造函数</li>
<li>@param start</li>
<li>@param end<br><em>&#x2F;<br>public TaskExample(int start, int end){<br>this.start &#x3D; start;<br>this.end &#x3D; end;<br>}<br>&#x2F;</em>*</li>
<li>The main computation performed by this task.</li>
<li></li>
<li>@return the result of the computation<br>*&#x2F;</li>
</ul>
<p>@Override<br>protected Long compute() {</p>
<p>System.out.println(“任务” + start + “&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;” + end + “累加开始”);<br>&#x2F;&#x2F;大于 100 个数相加切分,小于直接加<br>if(end - start &lt;&#x3D; 100 ){<br>for (int i &#x3D; start; i &lt;&#x3D; end; i++) {<br>&#x2F;&#x2F;累加<br>sum +&#x3D; i;<br>}<br>}else {<br>&#x2F;&#x2F;切分为 2 块<br>int middle &#x3D; start + 100 ;<br>&#x2F;&#x2F;递归调用,切分为 2 个小任务<br>TaskExample taskExample1 &#x3D; new TaskExample(start, middle);<br>TaskExample taskExample2 &#x3D; new TaskExample(middle + 1 , end);<br>&#x2F;&#x2F;执行:异步<br>taskExample1.fork();<br>taskExample2.fork();<br>&#x2F;&#x2F;同步阻塞获取执行结果<br>sum &#x3D; taskExample1.join() + taskExample2.join();<br>}<br>&#x2F;&#x2F;加完返回<br>return sum;<br>}<br>}</p>
<p>package com.atguigu.test;</p>
<p>import java.util.concurrent.ForkJoinPool;</p>
<p>import java.util.concurrent.ForkJoinTask;</p>
<h5 id="x2F-49"><a href="#x2F-49" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="分支合并案例"><a href="#分支合并案例" class="headerlink" title="* 分支合并案例"></a>* 分支合并案例</h5><h5 id="x2F-50"><a href="#x2F-50" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h5><p>public class ForkJoinPoolDemo {</p>
<h5 id="x2F-51"><a href="#x2F-51" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><h5 id="生成一个计算任务，计算1-2-3………-1000"><a href="#生成一个计算任务，计算1-2-3………-1000" class="headerlink" title="* 生成一个计算任务，计算1+2+3………+1000"></a>* 生成一个计算任务，计算1+2+3………+1000</h5><ul>
<li>@param args</li>
</ul>
<p>*&#x2F;</p>
<p>public static void main(String[] args) {</p>
<p>&#x2F;&#x2F;定义任务</p>
<p>TaskExample taskExample &#x3D; new TaskExample(1, 1000);</p>
<p>&#x2F;&#x2F;定义执行对象</p>
<p>ForkJoinPool forkJoinPool &#x3D; new ForkJoinPool();</p>
<p>&#x2F;&#x2F;加入任务执行</p>
<p>ForkJoinTask<Long> result &#x3D; forkJoinPool.submit(taskExample);</p>
<p>&#x2F;&#x2F;输出结果</p>
<p>try {</p>
<p>System.out.println(result.get());</p>
<p>}catch (Exception e){</p>
<p>e.printStackTrace();</p>
<p>}finally {</p>
<p>forkJoinPool.shutdown();</p>
<p>}</p>
<p>}</p>
<p>}</p>
<h1 id="12-CompletableFuture"><a href="#12-CompletableFuture" class="headerlink" title="12 CompletableFuture"></a>12 CompletableFuture</h1><h4 id="12-1-CompletableFuture简介"><a href="#12-1-CompletableFuture简介" class="headerlink" title="12 .1 CompletableFuture简介"></a>12 .1 CompletableFuture简介</h4><h4 id="CompletableFuture在Java里面被用于异步编程，异步通常意味着非阻塞，"><a href="#CompletableFuture在Java里面被用于异步编程，异步通常意味着非阻塞，" class="headerlink" title="CompletableFuture在Java里面被用于异步编程，异步通常意味着非阻塞，"></a>CompletableFuture在Java里面被用于异步编程，异步通常意味着非阻塞，</h4><h4 id="可以使得我们的任务单独运行在与主线程分离的其他线程中，并且通过回调可"><a href="#可以使得我们的任务单独运行在与主线程分离的其他线程中，并且通过回调可" class="headerlink" title="可以使得我们的任务单独运行在与主线程分离的其他线程中，并且通过回调可"></a>可以使得我们的任务单独运行在与主线程分离的其他线程中，并且通过回调可</h4><h4 id="以在主线程中得到异步任务的执行状态，是否完成，和是否异常等信息。"><a href="#以在主线程中得到异步任务的执行状态，是否完成，和是否异常等信息。" class="headerlink" title="以在主线程中得到异步任务的执行状态，是否完成，和是否异常等信息。"></a>以在主线程中得到异步任务的执行状态，是否完成，和是否异常等信息。</h4><h4 id="CompletableFuture实现了Future-CompletionStage接口，实现了Future"><a href="#CompletableFuture实现了Future-CompletionStage接口，实现了Future" class="headerlink" title="CompletableFuture实现了Future, CompletionStage接口，实现了Future"></a>CompletableFuture实现了Future, CompletionStage接口，实现了Future</h4><h4 id="接口就可以兼容现在有线程池框架，而CompletionStage接口才是异步编程"><a href="#接口就可以兼容现在有线程池框架，而CompletionStage接口才是异步编程" class="headerlink" title="接口就可以兼容现在有线程池框架，而CompletionStage接口才是异步编程"></a>接口就可以兼容现在有线程池框架，而CompletionStage接口才是异步编程</h4><h4 id="的接口抽象，里面定义多种异步方法，通过这两者集合，从而打造出了强大的"><a href="#的接口抽象，里面定义多种异步方法，通过这两者集合，从而打造出了强大的" class="headerlink" title="的接口抽象，里面定义多种异步方法，通过这两者集合，从而打造出了强大的"></a>的接口抽象，里面定义多种异步方法，通过这两者集合，从而打造出了强大的</h4><h4 id="CompletableFuture类。"><a href="#CompletableFuture类。" class="headerlink" title="CompletableFuture类。"></a>CompletableFuture类。</h4><h4 id="12-2-Future与CompletableFuture"><a href="#12-2-Future与CompletableFuture" class="headerlink" title="12 .2 Future与CompletableFuture"></a>12 .2 Future与CompletableFuture</h4><h4 id="Futrue在Java里面，通常用来表示一个异步任务的引用，比如我们将任务提"><a href="#Futrue在Java里面，通常用来表示一个异步任务的引用，比如我们将任务提" class="headerlink" title="Futrue在Java里面，通常用来表示一个异步任务的引用，比如我们将任务提"></a>Futrue在Java里面，通常用来表示一个异步任务的引用，比如我们将任务提</h4><h4 id="交到线程池里面，然后我们会得到一个Futrue，在Future里面有isDone方"><a href="#交到线程池里面，然后我们会得到一个Futrue，在Future里面有isDone方" class="headerlink" title="交到线程池里面，然后我们会得到一个Futrue，在Future里面有isDone方"></a>交到线程池里面，然后我们会得到一个Futrue，在Future里面有isDone方</h4><h4 id="法来-判断任务是否处理结束，还有get方法可以一直阻塞直到任务结束然后获"><a href="#法来-判断任务是否处理结束，还有get方法可以一直阻塞直到任务结束然后获" class="headerlink" title="法来 判断任务是否处理结束，还有get方法可以一直阻塞直到任务结束然后获"></a>法来 判断任务是否处理结束，还有get方法可以一直阻塞直到任务结束然后获</h4><h4 id="取结果，但整体来说这种方式，还是同步的，因为需要客户端不断阻塞等待或"><a href="#取结果，但整体来说这种方式，还是同步的，因为需要客户端不断阻塞等待或" class="headerlink" title="取结果，但整体来说这种方式，还是同步的，因为需要客户端不断阻塞等待或"></a>取结果，但整体来说这种方式，还是同步的，因为需要客户端不断阻塞等待或</h4><h4 id="者不断轮询才能知道任务是否完成。"><a href="#者不断轮询才能知道任务是否完成。" class="headerlink" title="者不断轮询才能知道任务是否完成。"></a>者不断轮询才能知道任务是否完成。</h4><h4 id="Future的主要缺点如下："><a href="#Future的主要缺点如下：" class="headerlink" title="Future的主要缺点如下："></a>Future的主要缺点如下：</h4><h4 id="（-1-）不支持手动完成"><a href="#（-1-）不支持手动完成" class="headerlink" title="（ 1 ）不支持手动完成"></a>（ 1 ）不支持手动完成</h4><h4 id="我提交了一个任务，但是执行太慢了，我通过其他路径已经获取到了任务结果，"><a href="#我提交了一个任务，但是执行太慢了，我通过其他路径已经获取到了任务结果，" class="headerlink" title="我提交了一个任务，但是执行太慢了，我通过其他路径已经获取到了任务结果，"></a>我提交了一个任务，但是执行太慢了，我通过其他路径已经获取到了任务结果，</h4><h4 id="现在没法把这个任务结果通知到正在执行的线程，所以必须主动取消或者一直"><a href="#现在没法把这个任务结果通知到正在执行的线程，所以必须主动取消或者一直" class="headerlink" title="现在没法把这个任务结果通知到正在执行的线程，所以必须主动取消或者一直"></a>现在没法把这个任务结果通知到正在执行的线程，所以必须主动取消或者一直</h4><h4 id="等待它执行完成"><a href="#等待它执行完成" class="headerlink" title="等待它执行完成"></a>等待它执行完成</h4><h4 id="（-2-）不支持进一步的非阻塞调用"><a href="#（-2-）不支持进一步的非阻塞调用" class="headerlink" title="（ 2 ）不支持进一步的非阻塞调用"></a>（ 2 ）不支持进一步的非阻塞调用</h4><h4 id="通过Future的get方法会一直阻塞到任务完成，但是想在获取任务之后执行"><a href="#通过Future的get方法会一直阻塞到任务完成，但是想在获取任务之后执行" class="headerlink" title="通过Future的get方法会一直阻塞到任务完成，但是想在获取任务之后执行"></a>通过Future的get方法会一直阻塞到任务完成，但是想在获取任务之后执行</h4><h4 id="额外的任务，因为Future不支持回调函数，所以无法实现这个功能"><a href="#额外的任务，因为Future不支持回调函数，所以无法实现这个功能" class="headerlink" title="额外的任务，因为Future不支持回调函数，所以无法实现这个功能"></a>额外的任务，因为Future不支持回调函数，所以无法实现这个功能</h4><h4 id="（-3-）不支持链式调用"><a href="#（-3-）不支持链式调用" class="headerlink" title="（ 3 ）不支持链式调用"></a>（ 3 ）不支持链式调用</h4><h4 id="对于Future的执行结果，我们想继续传到下一个Future处理使用，从而形成"><a href="#对于Future的执行结果，我们想继续传到下一个Future处理使用，从而形成" class="headerlink" title="对于Future的执行结果，我们想继续传到下一个Future处理使用，从而形成"></a>对于Future的执行结果，我们想继续传到下一个Future处理使用，从而形成</h4><h4 id="一个链式的pipline调用，这在Future中是没法实现的。"><a href="#一个链式的pipline调用，这在Future中是没法实现的。" class="headerlink" title="一个链式的pipline调用，这在Future中是没法实现的。"></a>一个链式的pipline调用，这在Future中是没法实现的。</h4><h4 id="（-4-）不支持多个Future合并"><a href="#（-4-）不支持多个Future合并" class="headerlink" title="（ 4 ）不支持多个Future合并"></a>（ 4 ）不支持多个Future合并</h4><h4 id="比如我们有-10-个Future并行执行，我们想在所有的Future运行完毕之后，"><a href="#比如我们有-10-个Future并行执行，我们想在所有的Future运行完毕之后，" class="headerlink" title="比如我们有 10 个Future并行执行，我们想在所有的Future运行完毕之后，"></a>比如我们有 10 个Future并行执行，我们想在所有的Future运行完毕之后，</h4><h4 id="执行某些函数，是没法通过Future实现的。"><a href="#执行某些函数，是没法通过Future实现的。" class="headerlink" title="执行某些函数，是没法通过Future实现的。"></a>执行某些函数，是没法通过Future实现的。</h4><h4 id="（-5-）不支持异常处理"><a href="#（-5-）不支持异常处理" class="headerlink" title="（ 5 ）不支持异常处理"></a>（ 5 ）不支持异常处理</h4><h4 id="Future的API没有任何的异常处理的api，所以在异步运行时，如果出了问题"><a href="#Future的API没有任何的异常处理的api，所以在异步运行时，如果出了问题" class="headerlink" title="Future的API没有任何的异常处理的api，所以在异步运行时，如果出了问题"></a>Future的API没有任何的异常处理的api，所以在异步运行时，如果出了问题</h4><h4 id="是不好定位的。"><a href="#是不好定位的。" class="headerlink" title="是不好定位的。"></a>是不好定位的。</h4><h4 id="12-3-CompletableFuture入门"><a href="#12-3-CompletableFuture入门" class="headerlink" title="12 .3 CompletableFuture入门"></a>12 .3 CompletableFuture入门</h4><h4 id="12-3-1-使用CompletableFuture"><a href="#12-3-1-使用CompletableFuture" class="headerlink" title="12 .3.1 使用CompletableFuture"></a>12 .3.1 使用CompletableFuture</h4><h4 id="场景-主线程里面创建一个CompletableFuture，然后主线程调用get方法会"><a href="#场景-主线程里面创建一个CompletableFuture，然后主线程调用get方法会" class="headerlink" title="场景:主线程里面创建一个CompletableFuture，然后主线程调用get方法会"></a>场景:主线程里面创建一个CompletableFuture，然后主线程调用get方法会</h4><h4 id="阻塞，最后我们在一个子线程中使其终止。"><a href="#阻塞，最后我们在一个子线程中使其终止。" class="headerlink" title="阻塞，最后我们在一个子线程中使其终止。"></a>阻塞，最后我们在一个子线程中使其终止。</h4><h5 id="x2F-52"><a href="#x2F-52" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h5><ul>
<li>主线程里面创建一个CompletableFuture，然后主线程调用get方法会阻塞，最后我们<br>在一个子线程中使其终止</li>
<li>@param args<br>*&#x2F;<br>public static void main(String[] args) throws Exception{<br>CompletableFuture<String> future &#x3D; new CompletableFuture&lt;&gt;();<br>new Thread(() -&gt; {<br>try{<br>System.out.println(Thread.currentThread().getName() + “子线程开始干活”);<br>&#x2F;&#x2F;子线程睡 5 秒<br>Thread.sleep( 5000 );<br>&#x2F;&#x2F;在子线程中完成主线程<br>future.complete(“success”);<br>}catch (Exception e){<br>e.printStackTrace();<br>}<br>}, “A”).start();<br>&#x2F;&#x2F;主线程调用get方法阻塞<br>System.out.println(“主线程调用get方法获取结果为: “ + future.get());<br>System.out.println(“主线程完成,阻塞结束!!!!!!”);<br>}</li>
</ul>
<h4 id="12-3-2-没有返回值的异步任务"><a href="#12-3-2-没有返回值的异步任务" class="headerlink" title="12 .3.2 没有返回值的异步任务"></a>12 .3.2 没有返回值的异步任务</h4><h4 id="x2F-53"><a href="#x2F-53" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h4><h4 id="没有返回值的异步任务"><a href="#没有返回值的异步任务" class="headerlink" title="* 没有返回值的异步任务"></a>* 没有返回值的异步任务</h4><h4 id="param-args-2"><a href="#param-args-2" class="headerlink" title="* @param args"></a>* @param args</h4><h4 id="x2F-54"><a href="#x2F-54" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h4><h4 id="public-static-void-main-String-args-throws-Exception"><a href="#public-static-void-main-String-args-throws-Exception" class="headerlink" title="public static void main(String[] args) throws Exception{"></a>public static void main(String[] args) throws Exception{</h4><h4 id="System-out-println-“主线程开始”"><a href="#System-out-println-“主线程开始”" class="headerlink" title="System.out.println(“主线程开始”);"></a>System.out.println(“主线程开始”);</h4><h4 id="x2F-x2F-运行一个没有返回值的异步任务"><a href="#x2F-x2F-运行一个没有返回值的异步任务" class="headerlink" title="&#x2F;&#x2F;运行一个没有返回值的异步任务"></a>&#x2F;&#x2F;运行一个没有返回值的异步任务</h4><h4 id="CompletableFuture-future-x3D-CompletableFuture-runAsync"><a href="#CompletableFuture-future-x3D-CompletableFuture-runAsync" class="headerlink" title="CompletableFuture future &#x3D; CompletableFuture.runAsync(() -"></a>CompletableFuture<Void> future &#x3D; CompletableFuture.runAsync(() -</h4><h4 id="gt"><a href="#gt" class="headerlink" title="&gt; {"></a>&gt; {</h4><h4 id="try-4"><a href="#try-4" class="headerlink" title="try {"></a>try {</h4><h4 id="System-out-println-“子线程启动干活”"><a href="#System-out-println-“子线程启动干活”" class="headerlink" title="System.out.println(“子线程启动干活”);"></a>System.out.println(“子线程启动干活”);</h4><h4 id="Thread-sleep-5000-1"><a href="#Thread-sleep-5000-1" class="headerlink" title="Thread.sleep(5000);"></a>Thread.sleep(5000);</h4><h4 id="System-out-println-“子线程完成”"><a href="#System-out-println-“子线程完成”" class="headerlink" title="System.out.println(“子线程完成”);"></a>System.out.println(“子线程完成”);</h4><h4 id="catch-Exception-e-2"><a href="#catch-Exception-e-2" class="headerlink" title="} catch (Exception e) {"></a>} catch (Exception e) {</h4><h4 id="e-printStackTrace-2"><a href="#e-printStackTrace-2" class="headerlink" title="e.printStackTrace();"></a>e.printStackTrace();</h4><h4 id="-46"><a href="#-46" class="headerlink" title="}"></a>}</h4><h4 id="-47"><a href="#-47" class="headerlink" title="});"></a>});</h4><h4 id="x2F-x2F-主线程阻塞"><a href="#x2F-x2F-主线程阻塞" class="headerlink" title="&#x2F;&#x2F;主线程阻塞"></a>&#x2F;&#x2F;主线程阻塞</h4><h4 id="future-get"><a href="#future-get" class="headerlink" title="future.get();"></a>future.get();</h4><h4 id="System-out-println-“主线程结束”"><a href="#System-out-println-“主线程结束”" class="headerlink" title="System.out.println(“主线程结束”);"></a>System.out.println(“主线程结束”);</h4><h4 id="-48"><a href="#-48" class="headerlink" title="}"></a>}</h4><h4 id="12-3-3-有返回值的异步任务"><a href="#12-3-3-有返回值的异步任务" class="headerlink" title="12 .3.3 有返回值的异步任务"></a>12 .3.3 有返回值的异步任务</h4><h4 id="x2F-55"><a href="#x2F-55" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h4><h4 id="没有返回值的异步任务-1"><a href="#没有返回值的异步任务-1" class="headerlink" title="* 没有返回值的异步任务"></a>* 没有返回值的异步任务</h4><h4 id="param-args-3"><a href="#param-args-3" class="headerlink" title="* @param args"></a>* @param args</h4><h4 id="x2F-56"><a href="#x2F-56" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h4><h4 id="public-static-void-main-String-args-throws-Exception-1"><a href="#public-static-void-main-String-args-throws-Exception-1" class="headerlink" title="public static void main(String[] args) throws Exception{"></a>public static void main(String[] args) throws Exception{</h4><h4 id="System-out-println-“主线程开始”-1"><a href="#System-out-println-“主线程开始”-1" class="headerlink" title="System.out.println(“主线程开始”);"></a>System.out.println(“主线程开始”);</h4><h4 id="x2F-x2F-运行一个有返回值的异步任务"><a href="#x2F-x2F-运行一个有返回值的异步任务" class="headerlink" title="&#x2F;&#x2F;运行一个有返回值的异步任务"></a>&#x2F;&#x2F;运行一个有返回值的异步任务</h4><h4 id="CompletableFuture-future-x3D"><a href="#CompletableFuture-future-x3D" class="headerlink" title="CompletableFuture future &#x3D;"></a>CompletableFuture<String> future &#x3D;</h4><h4 id="CompletableFuture-supplyAsync-gt"><a href="#CompletableFuture-supplyAsync-gt" class="headerlink" title="CompletableFuture.supplyAsync(() -&gt; {"></a>CompletableFuture.supplyAsync(() -&gt; {</h4><h4 id="try-5"><a href="#try-5" class="headerlink" title="try {"></a>try {</h4><h4 id="System-out-println-“子线程开始任务”"><a href="#System-out-println-“子线程开始任务”" class="headerlink" title="System.out.println(“子线程开始任务”);"></a>System.out.println(“子线程开始任务”);</h4><h4 id="Thread-sleep-5000-2"><a href="#Thread-sleep-5000-2" class="headerlink" title="Thread.sleep(5000);"></a>Thread.sleep(5000);</h4><h4 id="catch-Exception-e-3"><a href="#catch-Exception-e-3" class="headerlink" title="} catch (Exception e) {"></a>} catch (Exception e) {</h4><h4 id="e-printStackTrace-3"><a href="#e-printStackTrace-3" class="headerlink" title="e.printStackTrace();"></a>e.printStackTrace();</h4><h4 id="-49"><a href="#-49" class="headerlink" title="}"></a>}</h4><h4 id="return-“子线程完成了-”"><a href="#return-“子线程完成了-”" class="headerlink" title="return “子线程完成了!”;"></a>return “子线程完成了!”;</h4><h4 id="-50"><a href="#-50" class="headerlink" title="});"></a>});</h4><h4 id="x2F-x2F-主线程阻塞-1"><a href="#x2F-x2F-主线程阻塞-1" class="headerlink" title="&#x2F;&#x2F;主线程阻塞"></a>&#x2F;&#x2F;主线程阻塞</h4><h4 id="String-s-x3D-future-get"><a href="#String-s-x3D-future-get" class="headerlink" title="String s &#x3D; future.get();"></a>String s &#x3D; future.get();</h4><h4 id="System-out-println-“主线程结束-子线程的结果为-”-s"><a href="#System-out-println-“主线程结束-子线程的结果为-”-s" class="headerlink" title="System.out.println(“主线程结束, 子线程的结果为:” + s);"></a>System.out.println(“主线程结束, 子线程的结果为:” + s);</h4><h4 id="-51"><a href="#-51" class="headerlink" title="}"></a>}</h4><h4 id="12-3-4-线程依赖"><a href="#12-3-4-线程依赖" class="headerlink" title="12 .3.4 线程依赖"></a>12 .3.4 线程依赖</h4><h4 id="当一个线程依赖另一个线程时，可以使用-thenApply-方法来把这两个线程串行"><a href="#当一个线程依赖另一个线程时，可以使用-thenApply-方法来把这两个线程串行" class="headerlink" title="当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行"></a>当一个线程依赖另一个线程时，可以使用 thenApply 方法来把这两个线程串行</h4><h4 id="化。"><a href="#化。" class="headerlink" title="化。"></a>化。</h4><h4 id="private-static-Integer-num-x3D-10"><a href="#private-static-Integer-num-x3D-10" class="headerlink" title="private static Integer num &#x3D; 10;"></a>private static Integer num &#x3D; 10;</h4><h4 id="x2F-57"><a href="#x2F-57" class="headerlink" title="&#x2F;**"></a>&#x2F;**</h4><h4 id="先对一个数加10-然后取平方"><a href="#先对一个数加10-然后取平方" class="headerlink" title="* 先对一个数加10,然后取平方"></a>* 先对一个数加10,然后取平方</h4><h4 id="param-args-4"><a href="#param-args-4" class="headerlink" title="* @param args"></a>* @param args</h4><h4 id="x2F-58"><a href="#x2F-58" class="headerlink" title="*&#x2F;"></a>*&#x2F;</h4><h4 id="public-static-void-main-String-args-throws-Exception-2"><a href="#public-static-void-main-String-args-throws-Exception-2" class="headerlink" title="public static void main(String[] args) throws Exception{"></a>public static void main(String[] args) throws Exception{</h4><h4 id="System-out-println-“主线程开始”-2"><a href="#System-out-println-“主线程开始”-2" class="headerlink" title="System.out.println(“主线程开始”);"></a>System.out.println(“主线程开始”);</h4><h4 id="CompletableFuture-future-x3D-1"><a href="#CompletableFuture-future-x3D-1" class="headerlink" title="CompletableFuture future &#x3D;"></a>CompletableFuture<Integer> future &#x3D;</h4><h4 id="CompletableFuture-supplyAsync-gt-1"><a href="#CompletableFuture-supplyAsync-gt-1" class="headerlink" title="CompletableFuture.supplyAsync(() -&gt; {"></a>CompletableFuture.supplyAsync(() -&gt; {</h4><h4 id="try-6"><a href="#try-6" class="headerlink" title="try {"></a>try {</h4><h4 id="System-out-println-“加-10-任务开始”"><a href="#System-out-println-“加-10-任务开始”" class="headerlink" title="System.out.println(“加 10 任务开始”);"></a>System.out.println(“加 10 任务开始”);</h4><h4 id="num-x3D-10"><a href="#num-x3D-10" class="headerlink" title="num +&#x3D; 10;"></a>num +&#x3D; 10;</h4><h4 id="catch-Exception-e-4"><a href="#catch-Exception-e-4" class="headerlink" title="} catch (Exception e) {"></a>} catch (Exception e) {</h4><h4 id="e-printStackTrace-4"><a href="#e-printStackTrace-4" class="headerlink" title="e.printStackTrace();"></a>e.printStackTrace();</h4><h4 id="-52"><a href="#-52" class="headerlink" title="}"></a>}</h4><h4 id="return-num"><a href="#return-num" class="headerlink" title="return num;"></a>return num;</h4><h4 id="thenApply-integer-gt"><a href="#thenApply-integer-gt" class="headerlink" title="}).thenApply(integer -&gt; {"></a>}).thenApply(integer -&gt; {</h4><h4 id="return-num-num"><a href="#return-num-num" class="headerlink" title="return num * num;"></a>return num * num;</h4><h4 id="-53"><a href="#-53" class="headerlink" title="});"></a>});</h4><h4 id="Integer-integer-x3D-future-get"><a href="#Integer-integer-x3D-future-get" class="headerlink" title="Integer integer &#x3D; future.get();"></a>Integer integer &#x3D; future.get();</h4><h4 id="System-out-println-“主线程结束-子线程的结果为-”-integer"><a href="#System-out-println-“主线程结束-子线程的结果为-”-integer" class="headerlink" title="System.out.println(“主线程结束, 子线程的结果为:” + integer);"></a>System.out.println(“主线程结束, 子线程的结果为:” + integer);</h4><h4 id="-54"><a href="#-54" class="headerlink" title="}"></a>}</h4><h4 id="12-3-5-消费处理结果"><a href="#12-3-5-消费处理结果" class="headerlink" title="12 .3.5 消费处理结果"></a>12 .3.5 消费处理结果</h4><h4 id="thenAccept-消费处理结果-接收任务的处理结果，并消费处理，无返回结果。"><a href="#thenAccept-消费处理结果-接收任务的处理结果，并消费处理，无返回结果。" class="headerlink" title="thenAccept 消费处理结果, 接收任务的处理结果，并消费处理，无返回结果。"></a>thenAccept 消费处理结果, 接收任务的处理结果，并消费处理，无返回结果。</h4><p>public static void main(String[] args) throws Exception{</p>
<p>System.out.println(“主线程开始”);</p>
<p>CompletableFuture.supplyAsync(() -&gt; {</p>
<p>try {</p>
<p>System.out.println(“加 10 任务开始”);</p>
<p>num +&#x3D; 10;</p>
<p>} catch (Exception e) {</p>
<p>e.printStackTrace();</p>
<p>}</p>
<p>return num;</p>
<p>}).thenApply(integer -&gt; {</p>
<p>return num * num;</p>
<p>}).thenAccept(new Consumer<Integer>() {</p>
<p>@Override</p>
<p>public void accept(Integer integer) {</p>
<p>System.out.println(“子线程全部处理完成,最后调用了accept,结果为:” +<br>integer);</p>
<p>}</p>
<p>});</p>
<p>}</p>
<h4 id="12-3-6-异常处理"><a href="#12-3-6-异常处理" class="headerlink" title="12 .3.6 异常处理"></a>12 .3.6 异常处理</h4><h4 id="exceptionally异常处理-出现异常时触发"><a href="#exceptionally异常处理-出现异常时触发" class="headerlink" title="exceptionally异常处理,出现异常时触发"></a>exceptionally异常处理,出现异常时触发</h4><p>public static void main(String[] args) throws Exception{</p>
<p>System.out.println(“主线程开始”);</p>
<p>CompletableFuture<Integer> future &#x3D; CompletableFuture.supplyAsync(() -&gt; {</p>
<p>int i&#x3D; 1&#x2F;0;</p>
<p>System.out.println(“加 10 任务开始”);</p>
<p>num +&#x3D; 10;</p>
<p>return num;</p>
<p>}).exceptionally(ex -&gt; {</p>
<p>System.out.println(ex.getMessage());</p>
<p>return -1;</p>
<p>});</p>
<p>System.out.println(future.get());</p>
<p>}</p>
<p>handle类似于thenAccept&#x2F;thenRun方法,是最后一步的处理调用,但是同时可以处理异常</p>
<p>public static void main(String[] args) throws Exception{<br>System.out.println(“主线程开始”);<br>CompletableFuture<Integer> future &#x3D; CompletableFuture.supplyAsync(() -&gt; {<br>System.out.println(“加 10 任务开始”);<br>num +&#x3D; 10 ;<br>return num;<br>}).handle((i,ex) -&gt;{<br>System.out.println(“进入handle方法”);<br>if(ex !&#x3D; null){<br>System.out.println(“发生了异常,内容为:” + ex.getMessage());<br>return - 1 ;<br>}else{<br>System.out.println(“正常完成,内容为: “ + i);<br>return i;<br>}</p>
<h5 id="-55"><a href="#-55" class="headerlink" title="});"></a>});</h5><p>System.out.println(future.get());<br>}</p>
<h4 id="12-3-7-结果合并"><a href="#12-3-7-结果合并" class="headerlink" title="12 .3.7 结果合并"></a>12 .3.7 结果合并</h4><h4 id="thenCompose合并两个有依赖关系的CompletableFutures的执行结果"><a href="#thenCompose合并两个有依赖关系的CompletableFutures的执行结果" class="headerlink" title="thenCompose合并两个有依赖关系的CompletableFutures的执行结果"></a>thenCompose合并两个有依赖关系的CompletableFutures的执行结果</h4><p>public static void main(String[] args) throws Exception{<br>System.out.println(“主线程开始”);<br>&#x2F;&#x2F;第一步加 10<br>CompletableFuture<Integer> future &#x3D; CompletableFuture.supplyAsync(() -&gt; {<br>System.out.println(“加 10 任务开始”);<br>num +&#x3D; 10 ;<br>return num;<br>});<br>&#x2F;&#x2F;合并<br>CompletableFuture<Integer> future1 &#x3D; future.thenCompose(i - &gt;<br>&#x2F;&#x2F;再来一个CompletableFuture<br>CompletableFuture.supplyAsync(() -&gt; {<br>return i + 1 ;<br>}));<br>System.out.println(future.get());<br>System.out.println(future1.get());<br>}</p>
<p>thenCombine合并两个没有依赖关系的CompletableFutures任务</p>
<p>public static void main(String[] args) throws Exception{<br>System.out.println(“主线程开始”);</p>
<p>CompletableFuture<Integer> job1 &#x3D; CompletableFuture.supplyAsync(() -&gt; {<br>System.out.println(“加 10 任务开始”);<br>num +&#x3D; 10 ;<br>return num;<br>});</p>
<p>CompletableFuture<Integer> job2 &#x3D; CompletableFuture.supplyAsync(() -&gt; {</p>
<p>System.out.println(“乘以 10 任务开始”);<br>num &#x3D; num * 10 ;<br>return num;<br>});<br>&#x2F;&#x2F;合并两个结果<br>CompletableFuture<Object> future &#x3D; job1.thenCombine(job2, new<br>BiFunction&lt;Integer, Integer, List<Integer>&gt;() {<br>@Override<br>public List<Integer> apply(Integer a, Integer b) {<br>List<Integer> list &#x3D; new ArrayList&lt;&gt;();<br>list.add(a);<br>list.add(b);<br>return list;<br>}<br>});<br>System.out.println(“合并结果为:” + future.get());</p>
<p>}</p>
<p>合并多个任务的结果allOf与anyOf</p>
<p><strong>allOf:</strong> 一系列独立的future任务，等其所有的任务执行完后做一些事情</p>
<p>&#x2F;**</p>
<ul>
<li>先对一个数加10,然后取平方</li>
<li>@param args<br>*&#x2F;<br>public static void main(String[] args) throws Exception{<br>System.out.println(“主线程开始”);<br>List<CompletableFuture> list &#x3D; new ArrayList&lt;&gt;();<br>CompletableFuture<Integer> job1 &#x3D; CompletableFuture.supplyAsync(() -&gt; {<br>System.out.println(“加 10 任务开始”);<br>num +&#x3D; 10 ;<br>return num;<br>});<br>list.add(job1);</li>
</ul>
<p>CompletableFuture<Integer> job2 &#x3D; CompletableFuture.supplyAsync(() -&gt; {<br>System.out.println(“乘以 10 任务开始”);</p>
<p>num &#x3D; num * 10 ;<br>return num;<br>});<br>list.add(job2);</p>
<p>CompletableFuture<Integer> job3 &#x3D; CompletableFuture.supplyAsync(() -&gt; {<br>System.out.println(“减以 10 任务开始”);<br>num &#x3D; num * 10 ;<br>return num;<br>});<br>list.add(job3);</p>
<p>CompletableFuture<Integer> job4 &#x3D; CompletableFuture.supplyAsync(() -&gt; {<br>System.out.println(“除以 10 任务开始”);<br>num &#x3D; num * 10 ;<br>return num;<br>});<br>list.add(job4);<br>&#x2F;&#x2F;多任务合并<br>List<Integer> collect &#x3D;<br>list.stream().map(CompletableFuture<Integer>::join).collect(Collectors.toList());<br>System.out.println(collect);<br>}</p>
<p><strong>anyOf</strong> : 只要在多个future里面有一个返回，整个任务就可以结束，而不需要等到每一个<br>future结束</p>
<p>&#x2F;**</p>
<ul>
<li>先对一个数加10,然后取平方</li>
<li>@param args<br>*&#x2F;<br>public static void main(String[] args) throws Exception{<br>System.out.println(“主线程开始”);<br>CompletableFuture<Integer>[] futures &#x3D; new CompletableFuture[ 4 ];<br>CompletableFuture<Integer> job1 &#x3D; CompletableFuture.supplyAsync(() -&gt; {<br>try{<br>Thread.sleep( 5000 );<br>System.out.println(“加 10 任务开始”);</li>
</ul>
<p>num +&#x3D; 10 ;<br>return num;<br>}catch (Exception e){<br>return 0 ;<br>}<br>});<br>futures[ 0 ] &#x3D; job1;</p>
<p>CompletableFuture<Integer> job2 &#x3D; CompletableFuture.supplyAsync(() -&gt; {<br>try{<br>Thread.sleep( 2000 );<br>System.out.println(“乘以 10 任务开始”);<br>num &#x3D; num * 10 ;<br>return num;<br>}catch (Exception e){<br>return 1 ;<br>}</p>
<p>});<br>futures[ 1 ] &#x3D; job2;</p>
<p>CompletableFuture<Integer> job3 &#x3D; CompletableFuture.supplyAsync(() -&gt; {<br>try{<br>Thread.sleep( 3000 );<br>System.out.println(“减以 10 任务开始”);<br>num &#x3D; num * 10 ;<br>return num;<br>}catch (Exception e){<br>return 2 ;<br>}</p>
<p>});<br>futures[ 2 ] &#x3D; job3;</p>
<p>CompletableFuture<Integer> job4 &#x3D; CompletableFuture.supplyAsync(() -&gt; {<br>try{<br>Thread.sleep( 4000 );<br>System.out.println(“除以 10 任务开始”);</p>
<p>num &#x3D; num * 10 ;<br>return num;<br>}catch (Exception e){<br>return 3 ;<br>}<br>});<br>futures[ 3 ] &#x3D; job4;<br>CompletableFuture<Object> future &#x3D; CompletableFuture.anyOf(futures);<br>System.out.println(future.get());<br>}</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://example.com/2022/06/27/JUC/" title="" target="_blank" rel="external">http://example.com/2022/06/27/JUC/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/cofess" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/cofess" target="_blank"><span class="text-dark">D-creater</span><small class="ml-1x">Web Developer &amp; Designer</small></a></h3>
        <div>个人简介。</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    
    <li class="next">
      <a href="/2022/06/22/docker/" title="(no title)"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>$</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>Maybe you could buy me a cup of coffee.</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/images/donate/alipayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open alipay app scan this qrcode, buy me a coffee!</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/images/donate/wechatpayimg.png" alt="Scan Qrcode" title="Scan" />
              </div>
              <p class="text-muted mv">Scan this qrcode</p>
              <p class="text-grey">Open wechat app scan this qrcode, buy me a coffee!</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> alipay</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> wechat payment</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/cofess" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="http://weibo.com/cofess" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
        <li><a href="https://twitter.com/iwebued" target="_blank" title="Twitter" data-toggle=tooltip data-placement=top><i class="icon icon-twitter"></i></a></li>
        
        <li><a href="https://www.behance.net/cofess" target="_blank" title="Behance" data-toggle=tooltip data-placement=top><i class="icon icon-behance"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>